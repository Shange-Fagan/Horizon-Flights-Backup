<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Airbnb Assistant</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <!-- Stylesheets and scripts will be included here -->
  <style>
  /* Global Styles */
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  overflow: hidden;
  /*font-family: "Syne", sans-serif;*/
}

a, button, input, select, iframe {
  pointer-events: auto;
}

/* Info and Credits */
#info,
#credits {
  position: absolute;
  width: 100%;
  text-align: center;
  /*color: teal;*/
  color: rgba(255, 255, 255, 0.5);
  z-index: 22012;
}

#info {
  bottom: 3.75vh;
  font-size: 0.75rem;
}

#credits {
      bottom: 2vh;
      font-size: 0.75rem; /* Smaller, more discreet font size */
      /*color: rgba(0, 0, 0, 0.4);*/ /* Make the credits less prominent */
    }
 #credits a {
      color: #1e90ff;
      text-decoration: none;
    }

    #credits a:hover {
      text-decoration: underline;
    }
/* Tickers */
#dayTicker,
#nightTicker {
  display: block; /* Show day ticker by default */
      position: fixed;
      top: 0vh;
      color: teal;
      width: 100%;
	height: 60px;
      font-family: Monospace;
       text-align: center;
      z-index: 22011;
    
}
	  #searchTicker{
  display: none; /* Show day ticker by default */
      position: fixed;
      top: 0vh;
      color: teal;
      width: 100%;
	height: 60px;
      font-family: Monospace;
       text-align: center;
      z-index: 22011;
    
}
#trivagoIframeContainer {
  display: none; /* Show day ticker by default */
      position: fixed;
      top: 0vh;
      color: teal;
      width: 100%;
	height: 60px;
      font-family: Monospace;
       text-align: center;
      z-index: 22011;
    
}
	  #mobileTicker {
  display: none; /* Show day ticker by default */
      position: fixed;
      top: 0vh;
      color: teal;
      width: 100%;
      font-family: Monospace;
       text-align: center;
      z-index: 22011;
    
}
	  /* Responsive Ticker for Mobile */
    /*@media (max-width: 768px) {
      #dayTicker, #nightTicker {
        font-size: 10px;
	width: 60px;
        height: 60px;
        top: 0;
      }
    }*/
	  @media (max-width: 768px) {
      #dayTicker, #nightTicker {
        display: none;
      }
    }
@media (max-width: 768px) {
      #mobileTicker {
        display: block;
      }
    }
	  @media (min-width: 768px) {
      #mobileTicker {
        display: none;
      }
		  @media (max-width: 768px) {
      #mobileTicker {
        font-size: 10px;
	width: 60px;
        height: 60px;
        top: 0;
      }
    }
    }
/* Marker Labels */
/*.marker-label {
  position: absolute;
  object-fit: contain;
  font-family: 'Space Mono', monospace;
  transition: opacity 0.3s;
  background: transparent;
  width: 142px;
  height: 186px;
  border: 4px solid rgb(0, 107, 63);
  border-radius: 10px;
  z-index: 10;
  margin: 0;
  padding: 0;
  display: none; /* Hidden by default */
/*}*/
    
 .marker-label * {
  /* Styles here could affect all child elements, including the iframe */
}
  .marker-label {
  /*width: 300px;
  height: 200px;
  background: white;
  border: 2px solid #006b3f;
  border-radius: 10px;*/
  position: absolute;
  max-width: 300px;
  /*top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);*/
  /*z-index: 10;*/
  display: none; /* Hidden by default */
  pointer-events: auto; /* Ensure pointer events are enabled */
  z-index: 22009; /* Make sure the label is above other elements */
  /*background-color: rgba(255, 255, 255, 0.9);*/ /* Optional background for better visibility */
  /*overflow: hidden;*/ /* Hide any content that overflows */
}
	  
.marker-label.active {
  display: block;
}

/*.marker-label .close-button {
  position: absolute;
  top: 25px;
  left: 20px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid lightgray;
  border-radius: 3px;
  color: white;
  font-size: 14px;
  font-weight: bold;
  opacity: 0.25;
  transition: opacity 0.3s;
  cursor: pointer;
  z-index: 11;
}*/
	  /*.marker-label .close-button {
  position: absolute;
  top: 4.5px;
  left: 15px;
  background: rgba(0, 0, 0, 0.5); /* Darker background for visibility */
  /*border: 1px solid lightgray;
  border-radius: 3px;
  color: white;
  font-size: 14px;
  font-weight: bold;
  padding: 5px; */ /* Increase padding for larger click area */
  /*cursor: pointer;
  z-index: 9999;
  opacity: 0.25;
  transition: opacity 0.3s;
}*/
	  /* Close Button Styles */
 /* .close-button {
  position: absolute;
  top: 5px;*/ /* Adjust as needed */ /*
  right: 50px;*/ /* Adjust to your desired position */
  /*background: rgba(0, 0, 0, 0.5);*/
 /* background: rgba(0, 0, 0, 0.0)
  border: none;*/
  /*border-radius: 3px;*/
  /*border-radius: 100px;*/
  /*color: white;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;*/
  /*opacity: 0.25;*/
 /* z-index: 20000;*/ /* Ensure the close button is always on top */
/*}*/
	  .close-button {
  position: absolute;
  top: 5px;
  right: 10px;
  padding: 10px;
  width: 40px;
  height: 40px;
  background-color: rgba(255, 255, 255, 0.5);
  color: rgba(106, 106, 117, 1);;
  font-size: 14px;
  font-weight: bold;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  z-index: 22011; /* Ensure the close button is always on top */  /*display: flex;*/
  display: none;
  justify-content: center;
  align-items: center;
}

/*.close-button:hover {
  background: rgba(0, 0, 0, 0.8); /* Add a hover effect */
/*}*/

.marker-label iframe {
  width: 100%; /* Make iframe take full width */
  height: 300px; /* Adjust height as needed */
  border: none;
  display: block; /* Ensure iframe is a block element */
  /*z-index: 1;*/
}

.close-button:hover {
  opacity: 1;
  color: red; /* Optional color change on hover */
}

/*.marker-label .content {
  margin: 4px;
  width: calc(100% - 8px); // Adjust for margins 
  height: calc(100% - 8px);
}*/

.marker-label iframe {
  /*width: 100%;
  height: 100%;
  border: none;
  display: block;
  position: relative;*/
  /*z-index: 1;*/
  /*width: 100%; */ /* Make iframe take full width */
  /*height: 250px; */ /* Adjust height as needed */
  /*border: none; */ /* Remove iframe border */
  /*display: block;*/ /* Ensure it's a block element */
}
	  /*.marker-label iframe {
    width: 100%;
    height: 100%;
    border: none;
    display: block;
  }*/
    /* Button Style */
    #toggleButton {
      position: absolute;
      right: 15px;
      top: 200px;
      padding: 4.5px 9.5px;
      font-size: 12px;
      /*background-color: rgba(255, 255, 255, 0.2);*/
      /*border: 1px solid rgba(255, 255, 255, 0.25);*/
      /*border-radius: 8px;*/
      color: rgba(255, 255, 255, 0.75);
      z-index: 22011;
      cursor: pointer;
	    border: 0px solid #e0e0e0; /* Border similar to Airbnb */
       background-color: rgba(255, 255, 255, 0.15);
  border-radius: 25px; /* Rounded corners for inputs */
	    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }

    #toggleButton:hover {
      background-color: rgba(225, 225, 225, 0.35);
	    border-color: #ff385c; /* Red border on hover for consistency with Airbnb style */
    }
	  /* Airbnb-style Header */
 /* Airbnb-style Header */
/* Airbnb-style Header */
#header {
    position: fixed; /* Fixed to stay at the top while scrolling */
    top: 55px;
    left: 0;
    width: 100%;
    display: flex;
    justify-content: center; /* Center the header content */
    align-items: center;
    background-color: rgba(255, 255, 255, 0.15);
    padding: 12px 0px; /* Reduce padding for a cleaner, compact look */
    /*box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);*/ /* Light shadow for depth */
    z-index: 22011;
}

/* Inputs and dropdowns styling */
/* Styling for the input field (From) */
#from {
  font-size: 16px; /* Slightly smaller font size */
    padding: 10px 15px; /* Padding inside inputs */
    border: 0px solid #ddd; /* Light gray border */
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 50px; /* Fully rounded corners for inputs */
    margin-right: 10px; /* Spacing between input fields */
    width: 220px; /* Slightly smaller width */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	color: rgba(255, 255, 255, 0.75);
    width: 115px; /* Set width to auto */
    max-width: max-content; /* Ensure it adjusts based on the placeholder or content */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    white-space: nowrap; /* Prevent wrapping */
    cursor: default;
  }
  #adults {
  font-size: 16px; /* Slightly smaller font size */
    padding: 10px 15px; /* Padding inside inputs */
    border: 0px solid #ddd; /* Light gray border */
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 50px; /* Fully rounded corners for inputs */
    margin-right: 10px; /* Spacing between input fields */
    width: 225px; /* Slightly smaller width */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	color: rgba(255, 255, 255, 0.75);
    width: 85px; /* Set width to auto */
    max-width: max-content; /* Ensure it adjusts based on the placeholder or content */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    white-space: nowrap; /* Prevent wrapping */
    cursor: default;
  }
/* Styling for other inputs (optional) */
#where {
  font-size: 16px; /* Slightly smaller font size */
    padding: 10px 15px; /* Padding inside inputs */
    border: 0px solid #ddd; /* Light gray border */
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 50px; /* Fully rounded corners for inputs */
    margin-right: 10px; /* Spacing between input fields */
    width: 220px; /* Slightly smaller width */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	color: rgba(255, 255, 255, 0.75);
    width: 75px; /* Set width to auto */
    max-width: max-content; /* Ensure it adjusts based on the placeholder or content */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    white-space: nowrap; /* Prevent wrapping */
    cursor: default;
  }
  /* Styling for other inputs (optional) */
#checkin, #checkout {
  font-size: 16px; /* Slightly smaller font size */
    padding: 10px 15px; /* Padding inside inputs */
    border: 0px solid #ddd; /* Light gray border */
    /*background-color: rgba(255, 255, 255, 0.15);*/
    border-radius: 50px; /* Fully rounded corners for inputs */
    margin-right: 10px; /* Spacing between input fields */
    /*width: 220px;*/ /* Slightly smaller width */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	/*color: rgba(255, 255, 255, 0.75);*/
    width: 125px; /* Set width to auto */
    /*max-width: max-content;*/ /* Ensure it adjusts based on the placeholder or content */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    white-space: nowrap; /* Prevent wrapping */
    cursor: default;
  }
  /* Styling for other inputs (optional) */
#price_min, #price_max {
  font-size: 16px; /* Slightly smaller font size */
    padding: 10px 15px; /* Padding inside inputs */
    border: 0px solid #ddd; /* Light gray border */
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 50px; /* Fully rounded corners for inputs */
    margin-right: 10px; /* Spacing between input fields */
    width: 220px; /* Slightly smaller width */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
	color: rgba(255, 255, 255, 0.75);
    width: 140px; /* Set width to auto */
    max-width: max-content; /* Ensure it adjusts based on the placeholder or content */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    white-space: nowrap; /* Prevent wrapping */
    cursor: default;
  }
#header input:focus, #header select:focus {
    outline: none;
      box-shadow: 0 0 8px rgba(255, 56, 92, 0.8); /* Red outline for focus similar to Airbnb */
}
	  #header input:hover, #header select:hover {
      box-shadow: 0 0 8px rgba(255, 56, 92, 0.8); /* Red outline for focus similar to Airbnb */
}


/* Button Styling */
#header button {
    background-color: #ff385c; /* Airbnb red color */
    border: none;
    padding: 10px 20px; /* Slightly smaller padding */
    border-radius: 50px; /* Fully rounded button */
    color: white;
    font-size: 16px;
    cursor: pointer;
    transition: background-color 0.3s ease;
     transition: background-color 0.3s ease, box-shadow 0.3s ease;
    box-shadow: 0 4px 8px rgba(0, 115, 187, 0.4), 0 1px 3px rgba(0, 115, 187, 0.12); /* Initial shadow */
    cursor: default;
}

#header button:hover {
    background-color: #e03a56; /* Darker red on hover */
    box-shadow: 0 0 12px rgba(0, 115, 255, 0.8), 0 0 4px rgba(0, 115, 255, 0.5); /* Brighter, thinner, blue shadow */
    /*border: 2px solid rgba(0, 115, 255, 0.8);*/ /* Optional: Blue border to make it more pronounced */
animation: pulseShadow 0.6s ease-in-out infinite alternate; /* Animation on hover */
}
/* Keyframes for box shadow pulse animation */
@keyframes pulseShadow {
    0% {
        box-shadow: 0 0 12px rgba(0, 115, 255, 0.8), 0 0 4px rgba(0, 115, 255, 0.5);
    }
    100% {
        box-shadow: 0 0 20px rgba(0, 115, 255, 1), 0 0 8px rgba(0, 115, 255, 0.75); /* Pulsating effect */
    }
}

/* Search section layout */
#header .search-section {
    display: flex;
    border-radius: 50px; /* Fully rounded container */
    padding: 10px 15px; /* Reduce padding */
    width: auto; /* Adjust width based on content */
    max-width: 100%; /* Ensure responsiveness */
    flex-wrap: wrap; /* Wrap content if it overflows */
	color: white;
	z-index: 22011; /* Ensure the entire search section is clickable */
}
	  
#header .logo {
    margin-right: auto; /* Push logo to the left */
    font-weight: bold;
    font-size: 24px; /* Slightly bigger logo text */
    color: #ff385c; /* Airbnb logo color */
}

/* Media Queries for Responsiveness */
@media (max-width: 768px) {
    #header {
        flex-direction: column;
        padding: 10px 0; /* Reduce padding for mobile */
    }

    #header input {
        width: 100%; /* Full width on mobile */
        margin-bottom: 10px;
    }

    #header button {
        width: 100%; /* Full width button on mobile */
    }

    #header .search-section {
        flex-direction: column; /* Stack inputs vertically */
        width: 100%;
        margin-top: 10px;
    }
}

/* Placeholder text styling */
#header input::placeholder {
    color: rgba(255, 255, 255, 0.75); /* Light gray placeholder text */
    font-size: 16px; /* Airbnb-style font size */
}
	  /* Styling for Specific Inputs */
input[type="text"]::placeholder,
input[type="date"]::placeholder {
  color: rgba(255, 255, 255, 0.75); /* Light gray placeholder for text and date inputs */
  opacity: 1; /* Ensure full opacity */
}

/* Date input custom styling */
/* Style the input[type="date"] */
input[type="date"] {
  appearance: none; /* Remove default appearance */
  -webkit-appearance: none; /* For Safari */
  padding: 10px;
  background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="rgba(255, 255, 255, 0.75)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>') no-repeat;
  background-position: right 10px center; /* Position the icon */
  background-size: 20px; /* Adjust the size of the icon */
  border: 1px solid #e0e0e0;
  color: rgba(255, 255, 255, 0.75); /* Text color */
  background-color: rgba(255, 255, 255, 0.15); /* Background */
  border-radius: 10px;
}
/* Red hover for date picker */
input[type="date"]:hover, input[type="date"]:focus {
    box-shadow: 0 0 8px rgba(255, 56, 92, 0.8); /* Red outline similar to Airbnb */
    outline: none;
}
input[type="date"]::-webkit-calendar-picker-indicator {
    opacity: 0; /* Hide the default calendar icon */
}
	  input[type="date" i] {
    font-family: monospace;
    padding-inline-start: 1px;
    cursor: default;
    padding: 0px;
    color: rgba(255, 255, 255, 0.75);
}/* Hide default number input arrows */
/* Hide default number input arrows */
input[type="number"]::-webkit-inner-spin-button, 
input[type="number"]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
}
input[type="date"]::placeholder {
    color: rgba(255, 255, 255, 0.75);
}


/* Older browser support for placeholders */
#header input::-webkit-input-placeholder {
  color: rgba(255, 255, 255, 0.75);
}

#header input::-moz-placeholder {
  color: rgba(255, 255, 255, 0.75);
}

#header input:-ms-input-placeholder {
  color: rgba(255, 255, 255, 0.75);
}

#header input::-ms-input-placeholder {
  color: rgba(255, 255, 255, 0.75);
}

#header input::placeholder {
  color: rgba(255, 255, 255, 0.75);
}

/* Style number input */
input[type="number"] {
    background-color: rgba(255, 255, 255, 0.15); /* Match other inputs' background */
    color: rgba(255, 255, 255, 0.75); /* Text color */
    padding: 10px 15px;
    border: 1px solid #e0e0e0;
    border-radius: 50px; /* Same rounded corners */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Consistent box-shadow */
    width: 50px;
}



/* Custom increment/decrement buttons */
#header .number-input-container button {
    background-color: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.75);
    font-size: 18px;
    cursor: pointer;
    padding: 0 10px;
    transition: color 0.3s ease;
}

#header .number-input-container button:hover {
    color: #ff385c; /* Airbnb red on hover */
}

#header .number-input-container button:focus {
    outline: none;
}



/*#regionPopup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(255, 255, 255, 0.15);
  padding: 20px;
  border-radius: 10px;
  z-index: 9999;*//* Ensure it appears above the globe */
 /* box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}*/
	  #regionPopup {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  /*background-color: rgba(255, 255, 255, 0.85);*//* Increased opacity for readability */
  background-color: rgba(255, 255, 255, 0.15);
  padding: 45px 55px; /* Increase padding for more breathing space */
  border-radius: 15px; /* Slightly more rounded corners */
  z-index: 22010; /* Ensure it appears above all other elements */
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); /* Deeper shadow for better separation */
  backdrop-filter: blur(10px); /* Apply background blur effect */
  text-align: center; /* Center the text and elements inside the popup */
  max-width: 400px; /* Limit the width for smaller screens */
  width: 100%;
}

#regionPopup h1, #regionPopup h2, #regionPopup p {
  /*color: #333;*/ /* Darker text color for better readability */
  color: rgba(255, 255, 255, 0.75);
  margin-bottom: 50px; /* Add space between title and content */
}

	#regionPopup select {
  font-size: 16px;
  padding: 10px;
  top: 100px;
  right: 30px;
  border-radius: 10px;
  border: 1px solid #e0e0e0;
  margin-bottom: 20px; /* Space between select and button */
  width: 82.5%; /* Adjust width to fit better within the container */
  margin-left: 10px; /* Center the select dropdown inside the popup */
  margin-right: 10px; /* Add equal padding to the right */
  box-sizing: border-box; /* Ensure padding and borders are included in the width */
  background-color: rgba(255, 255, 255, 0.15); /* Light background to improve look */
  appearance: none; /* Remove default select arrow styling for a custom look */
  -webkit-appearance: none; /* For WebKit browsers */
		display: block;
}
	  #regionPopup select:focus {
  outline: none; /* Remove the blue outline on focus */
}

#regionPopup select option {
  padding: 10px; /* Add padding to options */
}

#regionPopup button {
  background-color: #ff385c; /* Airbnb red */
  color: white;
  padding: 12px 25px;
  border: none;
  border-radius: 10px;
  font-size: 16px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

#regionPopup button:hover {
  background-color: #e03a56; /* Slightly darker red on hover */
}

	  #content {
  display: none;
  flex-direction: row;
}
/* Confirmation Message Styling */
#confirmationMessage {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
	color: rgba(255, 255, 255, 0.75);
  background-color: rgba(255, 255, 255, 0.15);
  padding: 30px;
  border-radius: 15px;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  z-index: 22011;
  text-align: center;
  max-width: 400px;
  width: 100%;
}

#confirmationMessage h2 {
  color: rgba(255, 255, 255, 0.75);
  margin-bottom: 10px;
}
	  #confirmationMessage p {
  color: rgba(255, 255, 255, 0.75);
	font-family: 'Airbnb Cereal App', 'Helvetica Neue', 'Arial', sans-serif;
}

/* Region Select Button Styling */
/* Region Select Button Styling */
#regionSelectBtn {
  position: absolute;
  top: 150px; /* Adjusted top position under Cheapest button */
  right: 15px;
  padding: 10px 15px; /* Add more padding for a better look */
  border: 0px solid #e0e0e0; /* No visible border */
  border-radius: 25px;
  font-size: 14px; /* Slightly larger font for better readability */
  cursor: pointer;
  transition: background-color 0.3s ease;
  color: rgba(255, 255, 255, 0.75); /* Keep the light gray text color */
  background-color: rgba(255, 255, 255, 0.15); /* Transparent background with slight white tint */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Shadow for depth */
  z-index: 22011;
}

#regionSelectBtn:hover {
  background-color: rgba(225, 225, 225, 0.35);
   border-color: #ff385c; /* Red border on hover for consistency with Airbnb style */
}
	  #regionSelectDropdown {
  padding: 10px;
  border-radius: 10px;
  border: 1px solid rgba(0, 0, 0, 0.1);
  background-color: rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.75);
  font-size: 14px;
  width: 200px; /* Adjust width */
  position: absolute; /* Adjust positioning */
  top: 200px; /* Adjust based on your layout */
  right: 50px; /* Adjust based on your layout */
  z-index: 22011; /* Ensure it is visible above other elements */
}
	  
#regionSelectDropdown:hover {
  background-color: rgba(245, 245, 245, 0.35);
}
	  #regionSelectBtn, #submitRegion {
  z-index:22011; /* Ensure these elements are interactive */
}

	  
/* Remove scrollbar from iframes */
iframe::-webkit-scrollbar {
  display: none;
}  #newsOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.3);
    /*background-color: rgba(0, 0, 0, 0.8);*/
    /*display: flex;*/
    display: none;  
    justify-content: center;
    align-items: center;
    z-index: 22013; /* Ensure it's on top of everything */
  }
	  #newsOverlaynighttheme {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: rgba(0, 0, 0, 0.3);
    /*background-color: rgba(0, 0, 0, 0.8);*/
    /*display: flex;*/
    display: none;  
    justify-content: center;
    align-items: center;
    z-index: 22013; /* Ensure it's on top of everything */
  }
  
  #newsIframe {
    width: 80%;
    height: 80%;
    /*background: rgba(255, 255, 255, 0.5);*/
    background: none;
    z-index: 1; /* Lower than the close button */
  }
	  #newsIframenighttheme {
    width: 80%;
    height: 80%;
    /*background: rgba(255, 255, 255, 0.5);*/
    background: none;
    z-index: 1; /* Lower than the close button */
  }

	  #newsButton {
    position: absolute;
      right: 15px;
      top: 240px;
      padding: 4.5px 9.5px;
      font-size: 12px;
      /*background-color: rgba(255, 255, 255, 0.2);*/
      /*border: 1px solid rgba(255, 255, 255, 0.25);*/
      /*border-radius: 8px;*/
      color: rgba(255, 255, 255, 0.75);
      z-index: 22022; /* Higher than the iframe */
      cursor: pointer;
	/*z-index: 9999;*/
     /*cursor: pointer;*/
	    border: 0px solid #e0e0e0; /* Border similar to Airbnb */
       background-color: rgba(255, 255, 255, 0.15);
  border-radius: 25px; /* Rounded corners for inputs */
	    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

#newsButton:hover {
  background-color: rgba(225, 225, 225, 0.35);
	border-color: #ff385c; /* Red border on hover for consistency with Airbnb style */

}
	  
	  #closeNewsButton {
  position: absolute;
  top: 10px;
  right: 10px;
  padding: 10px;
  width: 40px;
  height: 40px;
  background-color: rgba(255, 255, 255, 0.0);
  color: white;
  font-size: 24px;
  font-weight: bold;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  z-index: 22014;
  /*display: flex;*/
  display: none;
  justify-content: center;
  align-items: center;
}

#closeNewsButton:hover {
  /*background-color: rgba(255, 255, 255, 0.2);*/ /* Optional hover effect */
  color: red; /* Optional color change on hover */
}
	  #loadingIcon {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 22011;
  width: 50px; /* Adjust as needed */
  height: 50px;
	display: none;
}
	  .loading-spinner {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-top: 4px solid #fff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

	  #markerContainer {
  position: relative;
  display: inline-block; /* Ensures it wraps tightly around marker label */
}
	
	  /* Style the select dropdown */
/*select {
  position: absolute;
  left: 38px;
  top: 100px;
  padding: 4.5px 7.5px;
  font-size: 12px;*/
  /*background-color: rgba(255, 255, 255, 0.2);*/
 /*border: 1px solid rgba(255, 255, 255, 0.25);**/
 /*border-radius: 8px;*/
  /*color: rgba(255, 255, 255, 0.75);
  z-index: 9999;
  cursor: pointer;
  appearance: none;
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><polygon points="0,0 20,0 10,10" fill="rgba(255, 255, 255, 0.75)"/></svg>');
  background-repeat: no-repeat;
  background-position: right 25px center;
background-size: 10px; *//* Adjust this as needed */
/*overflow: hidden;*/
	/*z-index: 9999;*/
       /*cursor: pointer;*/
	  /*  border: 0px solid #e0e0e0;*/ /* Border similar to Airbnb */
      /* background-color: rgba(255, 255, 255, 0.15);
  border-radius: 25px; *//* Rounded corners for inputs */
	   /* box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}*/
	  select {
  position: absolute;
  right: 15px;
  top: 280px;
  padding: 4.5px 9.5px; /* Add padding for a better look */
  font-size: 12px; /* Increase the font size for better readability */
  color: rgba(255, 255, 255, 0.75); /* Keep the light gray text color */
  background-color: rgba(255, 255, 255, 0.15); /* Transparent background with slight white tint */
  border: 0px solid #e0e0e0; /* Add a border to separate the dropdown */
  border-radius: 25px; /* Rounded corners for the select box */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Shadow for depth */
  appearance: none; /* Removes the default arrow */
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><polygon points="0,0 20,0 10,10" fill="rgba(255, 255, 255, 0.75)"/></svg>');
  background-repeat: no-repeat;
  background-position: right 15px; /* Moves the arrow 5px to the left */ /* Adjusted to move the arrow down */
  background-size: 15px; /* Adjust the size of the arrow */
  background-position-x: 97.5%;
  cursor: pointer;
  z-index: 22011;
}
	  #airbnbSelector {
  appearance: none; /* Remove default appearance */
  -webkit-appearance: none; /* For Safari */
  position: absolute;
  right: 15px;
  top: 320px;
  padding: 4.5px 9.5px; /* Add padding for a better look */
  font-size: 12px; /* Increase the font size for better readability */
  color: rgba(255, 255, 255, 0.75); /* Keep the light gray text color */
  background-color: rgba(255, 255, 255, 0.15); /* Transparent background with slight white tint */
  border: 0px solid #e0e0e0; /* Add a border to separate the dropdown */
  border-radius: 25px; /* Rounded corners for the select box */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Shadow for depth */
  appearance: none; /* Removes the default arrow */
  background-size: 11px;
  background-position: right 15px;
  background-position-y: 69%;
  background-position-x: 97%;
  cursor: pointer;
  z-index: 22011;
  width: 198px;
}
	  /* Optional: Ensures the arrow is moved down without changing the default */
select::-ms-expand {
  display: none; /* Hide the arrow in IE/Edge */
}

select:hover {
  border-color: #ff385c; /* Red border on hover for consistency with Airbnb style */
	background-color: rgba(225, 225, 255, 0.35);
}

select:focus {
  border-color: #ff385c; /* Red border when focused */
  outline: none; /* Remove the default outline */
}

#priceCategorySelect {
  appearance: none; /* Remove default appearance */
  -webkit-appearance: none; /* For Safari */
  position: absolute;
  right: 15px;
  top: 280px;
  padding: 4.5px 9.5px; /* Add padding for a better look */
  font-size: 12px; /* Increase the font size for better readability */
  color: rgba(255, 255, 255, 0.75); /* Keep the light gray text color */
  background-color: rgba(255, 255, 255, 0.15); /* Transparent background with slight white tint */
  border: 0px solid #e0e0e0; /* Add a border to separate the dropdown */
  border-radius: 25px; /* Rounded corners for the select box */
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Shadow for depth */
  appearance: none; /* Removes the default arrow */
  background-size: 11px;
  background-position: right 15px;
  background-position-y: 69%;
  background-position-x: 95%;
  cursor: pointer;
  z-index: 22011;
  width: 133px;
}
/* Style the dropdown options */
select option {
  background-color: white;
  color: #333;
}


	/* Responsive Design */
    @media (max-width: 768px) {
      /* Adjust the size and placement of the globe on mobile */
      #toggleButton {
        font-size: 10px;
        padding: 3px 7px;
        top: 55px;
      }
	    select {
    padding: 3px 7px;
    top: 75px;    
    font-size: 10px;
    background-color: rgba(255, 255, 255, 0.2);
overflow: hidden;    
  }
	    
	    #newsButton {
        font-size: 10px;
        padding: 3px 7px;
        top: 55px;
      }

      /*#dayTicker, #nightTicker {
        height: 60px;*/ /* Reduce height for mobile */
        /*font-size: 12px;
	width: 100vw;
      }*/
	    #mobileTicker {
        height: 85px; /* Reduce height for mobile */
        font-size: 12px;
	width: 100vw;
      }

      #credits {
        font-size: 0.6rem; /* Make credits even smaller on mobile */
      }
	    #info {
  font-size: 0.6rem;
}
	    footer {
      font-size: 0.4rem;
    }

      /* Adjust globe view on smaller devices by zooming out */
      body {
        overflow: hidden;
      }
}
	
	  /* Footer Styles */
    footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      background-color: transparent;
      /*color: #fff;*/
      color: rgba(255, 255, 255, 0.5);
      text-align: center;
      padding: 5px 0;
      font-size: 0.6rem;
      z-index: 22012;
      /*font-size: 0.9rem;*/
      /*z-index: 9999;*/
    }

    footer a {
      color: #1e90ff;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
/* Responsive Footer for Mobile */
    @media (max-width: 768px) {
      footer {
        font-size: 0.4rem;
        padding: 2.5px 0;
      }
    }
/* Divide the screen into two sections */
#container {
  width: 100vw;
  height: 100vh;
	position: relative;
  z-index: 0;  /* Make sure the container is behind the globe-container */
	display: flex;  /* Use flexbox to manage layout */
}

/* Fullscreen globe when the page loads */
	  #globe-container {
  position: relative;  /* Set position to relative or absolute */
  width: 100%;
  height: 100%;
   display: block;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 22010;  /* Ensure it's in front of other elements if necessary */
		  float: right;
}

	  /* UI buttons that must be clickable over the globe */

/* Split the screen when the search button is clicked */
#globe-container.split {
  width: 50%;  /* Shrink to 50% width */
  height: 100vh;  /* Full height */
	
	  pointer-events: auto;  /* Allow interactions */
	float: right;
	position: relative;
}


/* Left container transition */

	/* Left container transition */
#left-container {
	height: 100vh;
    background-color: white;
    color: black;
    font-size: 16px;
    padding: 20px;
    display: none;  /* Hidden initially */
    width: 0;  /* Initially 0 width */
    position: relative;
    transition: width 0.5s ease;  /* Smooth transition for width */
    z-index: 22000;  /* Ensure it's in front of other elements if necessary */
	display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* This will ensure each item takes up equal space */
    gap: 15px; /* Add some spacing between the listings */
    padding: 20px;
    overflow-y: auto; /* Ensure it scrolls if the content overflows */

}	.close-btn {
    position: absolute;
    top: 10px;
    left: 20px; /* Move the button to the left */
    background-color: transparent;
    border: none;
    font-size: 20px;
    color: #000;
    cursor: pointer;
    display: none; /* Hidden initially */
    z-index: 22011; /* Ensure it's on top of other elements */
}

.close-btn:hover {
    color: #ff385c; /* Highlight on hover */
}  /* Style for each post */

/*#globeContainer {*/
  /*position: relative;  *//* Set position to relative or absolute */
  /*width: 100%;
  height: 100%;
  display: block !important;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 22011;*/  /* Ensure it's in front of other elements if necessary */
/*}*/
/*#globeContainer canvas {
  position: absolute;*/
  /*top: 0;
  left: 0;*/
  /*top: 0;
  left: 0;
  right: 0;
  bottom: 0;*/
  /*z-index: 22011;*/  /* Make sure the canvas is above any other elements */
	/*overflow: hidden;*/ /* Ensure the canvas doesn’t overflow */
		  /*display: block;
      pointer-events: auto;
      touch-action: auto;
}*/
#globeContainer {
  /*position: relative;*/  /* Set position to relative or absolute */
  width: 100%;
  height: 100%;
   display: block;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 22011;  /* Ensure it's in front of other elements if necessary */
		  float: right;
}
	  #globeContainer canvas {
  /*position: relative;*/
  /*top: 0;
  left: 0;*/
  z-index: 22011;  /* Make sure the canvas is above any other elements */
	overflow: hidden; /* Ensure the canvas doesn’t overflow */
		  display: block !important;
}
	  
	  #globeContainer {
    pointer-events: auto; /* Disable globe interactions */
}
	  #globeContainer.disable-interaction {
    pointer-events: none; /* Disable globe interactions */
}
/* Overlay container to hold posts, sits on the left side of the screen */
#overlayContainer {
  position: absolute;
  top: 135px;
  left: 15px;
  width: 45%; /* Adjust width as per your requirement */
  height: 72.5%;
  padding: 20px;
  border-radius: 15px;
  display: none;
  grid-template-columns: repeat(2, 1fr); /* Two equal columns */
  grid-auto-rows: minmax(300px, auto); /* Set a base row height with flexibility */
  gap: 50px; /* Space between the cards */
  background-color: rgba(255, 255, 255, 0.15); /* Slight transparency */
  overflow-y: auto; /* Enable scrolling if content overflows */
  z-index: 22012; /* On top of the globe container */
  box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3); /* Add shadow on the right side */
  /*box-sizing: border-box;*/
}

/* Styling for individual posts */
/*.post {
  background-color: white;
  border-radius: 10px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Card-like shadow */
  /*overflow: hidden;
  text-align: left; /* Align text to the left */
  /*padding: 10px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 100%; 
}

/* Image for each post */
/*.post img {
  width: 100%;
  height: 100%;
  max-height: 200px; /* Control max height of the image */
  /*object-fit: cover; /* Ensure the image fits within the space */
  /*border-radius: 10px; /* Rounded top corners */
  /*margin-bottom: 10px; /* Space below the image */
/*}

/* Title and other text elements */
/*.post h3 {
  font-size: 1.1rem; /* Slightly larger title */
  /*margin: 10px 0;
}

.post p {
  color: #696767;
  font-size: 0.9rem; /* Smaller font size */
/*}

/* Add a guest favorite badge */
/*.post .guest-favorite {
  position: absolute;
  top: 10px;
  left: 10px;
  background-color: #fff;
  padding: 5px 10px;
  border-radius: 20px;
  font-size: 0.8rem;
  font-weight: bold;
  color: #ff385c; */ /* Airbnb pink color */
  /*box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}*/

/* Rating and other text below the title */
.post .details {
  font-size: 0.9rem;
  color: #333;
}
.post {
  background-color: white;
  border-radius: 25px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  overflow: hidden;
  text-align: left;
  padding: 0px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.post img {
  width: 100%;
  height: 250px;
  object-fit: cover;
  border-radius: 25px;
  margin-bottom: 10px;
}

.post h3 {
  font-size: 1rem;
  margin: 5px 0;
}

.post p.details {
  font-size: 0.9rem;
  color: #696767;
}

.post .guest-favorite {
  position: absolute;
  top: 10px;
  left: 10px;
  background-color: white;
  color: #ff385c;
  font-weight: bold;
  font-size: 0.8rem;
  border-radius: 12px;
  padding: 5px 10px;
}

.post .view-link {
  background-color: #ff385c;
  color: white;
  padding: 8px 15px;
  text-align: center;
  border-radius: 20px;
  margin-top: auto;
  text-decoration: none;
  font-size: 0.9rem;
}

/* Button or link for each post */
/*.post .view-link {
  display: inline-block;
  margin-top: auto;*/ /* Push link to the bottom */
  /*padding: 8px 12px;
  background-color: #ff385c;
  color: white;
  border-radius: 50px;
  text-decoration: none;
  font-size: 0.9rem;
  text-align: center;
}*/

.post .view-link:hover {
  background-color: #e03a56;
}
/* Scrollbar customization */
#overlayContainer::-webkit-scrollbar {
  width: 10px;
}

#overlayContainer::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 5px;
}

#left-container::-webkit-scrollbar {
    width: 10px;
}

#left-container::-webkit-scrollbar-thumb {
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 5px;
}        
#overlayContainer.show {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    z-index: 22012;
}
#left-container.show {
    width: 50%;  /* Expands to 50% smoothly */
	display: block;
    background-color: white;
    color: black;
    font-size: 16px;
    padding: 20px;
    overflow-y: auto;
    z-index: 20010;  /* Ensure it's in front of other elements if necessary */
}
/* Spinner CSS */
.spinner-container {
    display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
    z-index: 22010;
	position: absolute;
  top: 200px;
    left: 50%;
    transform: translate(-50%, -50%);
    color: rgba(255, 255, 255, 0.75);
}

.spinner {
    border: 4px solid rgba(0, 0, 0, 0.1);
  border-left-color: rgba(255, 255, 255, 0.75);
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  color: rgba(255, 255, 255, 0.75);
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.spinner-text {
    margin-top: 10px;
    text-align: center;
    color: rgba(255, 255, 255, 0.75);
    font-size: 16px;
}
/* Full-screen opaque overlay */
/* Loading Screen */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 99999;
}

.active-loader {
  display: block;
}

.inactive-loader {
  display: none;
}

.hidden {
  width: 100%;
  height: 100%;
  display: none;
}

#instructionsOverlay {
  position: absolute;
  top: 40%;
  left: 0;
  width: 100%;
  background: rgba(0, 0, 0, 0);
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 1000;
  pointer-events: none;
}

.instruction-step {
  position: relative;
  width: 200px;
  height: 200px;
  margin-bottom: 20px;
}

.got-it-button {
  background-color: #ff385c; /* Airbnb red */
  color: white;
  padding: 12px 25px;
  border: none;
  border-radius: 10px;
  font-size: 16px;
  cursor: pointer;
  position: relative; /* Important for positioning the ::after element */
  overflow: hidden; /* Prevent the shiny effect from going outside the button */
  transition: background-color 0.3s ease;
}

.got-it-button::after {
  content: '';
  position: absolute;
  top: 0;
  left: -125%; /* Start outside the left boundary */
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.5);
  transform: skewX(-45deg); /* Create diagonal shine */
  transition: left 0.3s ease-out;
}

.got-it-button:hover {
  background-color: #e03a56; /* Slightly darker red on hover */
}

.got-it-button:hover::after {
  left: 100%; /* Move the shiny effect across the button */
}


.instruction-text {
  margin-top: 15px;
  font-size: 18px;
  color: white;
  text-align: center;
  font-family: Arial, sans-serif;
}

.glove-hand {
  width: 80px;
  height: auto;
  animation: handMove 2s infinite ease-in-out;
}

.pulsating-dot {
  position: absolute;
  width: 15px;
  height: 15px;
  background: white;
  border-radius: 50%;
  animation: pulse 1.5s infinite;
}

/* Glove hand animation */
@keyframes handMove {
  0%, 100% {
    transform: translate(0, 0);
  }
  50% {
    transform: translate(10px, 10px);
  }
}

/* Dot pulse animation */
@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  50% {
    transform: scale(1.5);
    opacity: 0.5;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

.toggle-container {
  display: flex;
  justify-content: center;
  margin: 20px 0;
}

.theme-switch {
  position: absolute;
  display: flex;
  right: 15px;
  width: 80px;
  height: 40px;
  top: 360px;
  z-index: 22011;
}

.theme-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ff385c;
  transition: 0.4s;
  border-radius: 40px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 32px;
  width: 32px;
  left: 4px;
  bottom: 4px;
  background-color: white;
  transition: 0.4s;
  border-radius: 50%;
}

.theme-switch input:checked + .slider {
  background-color: #00aaff; /* Trivago blue */
}

.theme-switch input:checked + .slider:before {
  transform: translateX(40px);
}

.logo-airbnb,
.logo-trivago {
  position: absolute;
  width: 20px;
  height: 20px;
  top: 50%;
  transform: translateY(-50%);
}

.logo-airbnb {
  left: 8px;
}

.logo-trivago {
  right: 8px;
}

.search-bar {
  display: flex;
  justify-content: center;
  padding: 10px;
}

.airbnb-button {
  background-color: #ff385c;
  color: white;
  border: none;
  cursor: pointer;
}

.trivago-button {
  background-color: #00aaff;
  color: white;
  border: none;
  cursor: pointer;
}

.hidden {
  display: none;
}

/*#loading-overlay.hidden {
  display: none;*/  /* Hidden by default or after hiding */
  /*visibility: hidden;*/  /* Ensure it's not visible */
  /*position: fixed;*/  /* Keep it fixed if it was over the entire screen */
  /*z-index: 1;
  top: 0;
  left: 0;
  width: 0%;
  height: 0%;
  opacity: 0;
  pointer-events: none;
}*/

/* Loader visibility settings */
/*.active-loader {
  display: block;
}

.inactive-loader {
  display: none;
}*/
/* Full-screen opaque overlay */
/*(#loading-overlay {
  width: 100vw;
  height: 100vh;
  background: rgba(155, 155, 155, 0.5);
  display: block; /* Ensure flex display for centering */
  /*justify-content: center; 
  align-items: center;
  z-index: 99999;
  visibility: visible;
  opacity: 1;
  transition: opacity 0.5s ease; /* Smooth fade-out transition */
/*}

#loading-overlay.hidden {
  opacity: 0; /* Smooth fade-out */
  /*pointer-events: none; /* Disable interactions */
  /*transition: opacity 0.5s ease; /* Match fade-out transition */
/*}
/* Loader visibility settings */
/*.active-loader {
  display: block;
}

.inactive-loader {
  display: none;
}

#loader1, #loader2 {
  width: 100px; /* Adjust as necessary */
  /*height: 100px;
  object-fit: contain;
}*/


#loadingSpinner {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  display: block;
}

.spinner2 {
  border: 16px solid #f3f3f3;
  border-radius: 50%;
  border-top: 16px solid #3498db;
  width: 120px;
  height: 120px;
  animation: spin 2s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

canvas[style="display: block; width: 769px; height: 640px;"]{
  pointer-events: auto !important;
}
canvas element.style {
    display: block !important;
    width: 769px;
    height: 640px;
    pointer-events: all !important;
}

input[type="date"]::-webkit-input-placeholder {
    color: rgba(255, 255, 255, 0.75);
}

input[type="date"]::-webkit-calendar-picker-indicator {
    filter: invert(75%); /* Adjust icon color for dark backgrounds */
}
input[type="date"] {
    color: rgba(251, 251, 251, 0.75);
    background-color: rgba(255, 255, 255, 0.15); /* Optional */
}
input[type="date"]::-webkit-datetime-edit {
    color: rgba(255, 255, 255, 0.75);
}


</style>
	<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5689710336620898"
     crossorigin="anonymous"></script>
</head>
<body>
  <div id="overlayContainer">
    <button id="closeBtn" class="close-btn">X</button>
    <!-- First post -->
    <div class="post">
      <img src="your-image-url-1.jpg" alt="Post Title 1" />
      <div class="guest-favorite">Guest favorite</div>
      <h3>Post Title 1</h3>
      <p class="details">Price per night, Location</p>
      <p class="details">Dates available</p>
      <p class="details">Rating: ★4.99</p>
      <a href="#" class="view-link">View Listing</a>
    </div>
  </div>
  <div id="globeContainer"></div>
  <!-- Loading overlay with two loaders (visible by default) -->
  <!-- Loading Screen -->
<div id="loadingScreen" class="loading-screen">
  <img id="loader1" src="js/Earth@1x-1.1s-200px-200px.svg" alt="Loading..." class="active-loader" />
  <img id="loader2" src="js/Default@1x-1.0s-200px-200px (2).svg" alt="Loading..." class="inactive-loader" />
</div>
<div class="toggle-container">
  <label class="theme-switch">
    <input type="checkbox" id="themeToggle">
    <span class="slider">
      <img src="js/trivago-logo.png" alt="Airbnb" style="display: none; left: 12px; justify-content: center;
  align-items: center;" class="logo-airbnb">
      <img src="js/airbnb-logo.png" alt="Trivago" style="right: 12px; justify-content: center;
  align-items: center;"class="logo-trivago">
    </span>
  </label>
</div>

<!-- Instructions Modal -->
<!-- Instructions Modal -->
<div id="instructionsOverlay" class="hidden">
  <div class="instruction-step hidden" id="dragInstruction">
    <img src="js/left-click.png" alt="Drag Gesture" class="glove-hand">
    <div class="pulsating-dot" style="top: 50%; left: 50%;"></div>
    <p class="instruction-text">Drag across the globe to explore different regions.</p>
  </div>
  <div class="instruction-step hidden" id="zoomInstruction">
    <img src="js/pinch-3.png" alt="Scroll Gesture" class="glove-hand">
    <div class="pulsating-dot" style="top: 60%; left: 55%;"></div>
    <p class="instruction-text">Use your mouse or trackpad to zoom in and out.</p>
  </div>
  <div class="instruction-step hidden" id="themeInstruction">
    <img src="js/white-glove-scroll.png" alt="Button Click" class="glove-hand">
    <div class="pulsating-dot" style="top: 70%; left: 60%;"></div>
    <p class="instruction-text">Click the buttons on the right to switch themes or explore options.</p>
  </div>
  <div class="instruction-step hidden" id="toggleInstruction">
    <img src="js/white-glove-scroll.png" alt="Button Click" class="glove-hand">
    <div class="pulsating-dot" style="top: 70%; left: 60%;"></div>
    <p class="instruction-text">Switch between trivago or airbnb results using the buttons on the right.</p>
  </div>
</div>
<button id="gotItBtn" class="got-it-button hidden">Got it!</button>




<div id="container">
<div id="left-container" style="display: none;" class="split-screen-left"></div>
    </div>
  </div>
  
  <!-- Info Section -->
  <div id="info">Click the markers to show the label</div>
  <div id="credits">
    Made by
    <a href="https://www.linkedin.com/in/shange-fagan-bba3a3239/" target="_blank" rel="noopener">Shange Fagan</a>
  </div>
	<!-- Footer Section -->
  <footer>
    © 2024 Airbnb Assistant. All rights reserved. 
    <a href="https://www.linkedin.com/in/shange-fagan-bba3a3239/" target="_blank">LinkedIn</a> | 
    <a href="https://instagram.com/shangefagan" target="_blank">Instagram</a>
  </footer>

<div id="header">
  <input type="text" id="from" name="travel_from" placeholder="Departure Point">
  <input type="text" id="where" name="destination" placeholder="Where to?">
  <input type="date" id="checkin" name="checkin" placeholder="Check-in date">
  <input type="date" id="checkout" name="checkout" placeholder="Check-out date">
  <input type="number" id="adults" name="adults" placeholder="Add guests">
  <input type="number" id="price_min" name="price_min" placeholder="Min price (optional)">
  <input type="number" id="price_max" name="price_max" placeholder="Max price (optional)">
  <button id="searchBtn" class="airbnb-button">Search</button>
</div>
	
<div id="regionPopup">
  <h2>Welcome to Airbnb Assistant</h2>
  <p>Select your region</p>
  <select id="regionSelect">
    <option value="africa">Africa</option>
    <option value="europe">Europe</option>
    <!-- more regions -->
    <option value="america">America</option>
    <option value="south america">South America</option>
    <option value="carribbean">Carribbean</option>
    <option value="asia">Asia</option>
    <option value="world">World</option>
  </select>
  <button id="submitRegion">Submit</button>
</div>
	<!-- Add this dropdown for price categories -->
	<select id="priceCategorySelect">
    <optgroup label="Region-Specific Categories">
      <option value="disabled">Sort by (Region)📍</option>
        <option value="popular">Most Popular(in Region)📍</option>
        <option value="cheapest">Cheapest📍</option>
        <option value="midPrice">Mid Price📍</option>
        <option value="expensive">Expensive📍</option>
    </optgroup>
		</select>
		<select id="airbnbSelector">
    <optgroup label="World Categories">
      <option value="disabled">Sort by (Across the World) 🌍</option>
        <option value="general">Most Popular(Across the World)🌍</option>
        <option value="cheapest">Cheapest🌍</option>
        <option value="midPrice">Mid Price🌍</option>
        <option value="expensive">Most Expensive🌍</option>
    </optgroup>
</select>



<div id="confirmationMessage" style="display: none;">
  <h2>Thank you</h2>
  <p>
    Please enter the details of your travel above, and we'll do our best to find the airbnbs tailored to your needs, or feel free to browse the best airbnbs around the world, You can filter by price range and region using the buttons above.
  </p>
</div>

<!-- Region Select button -->
<button id="regionSelectBtn">Region Select</button>


<!-- Tickers -->
  <iframe
    id="dayTicker"
    class="iframe-container"
    src="https://rss.app/embed/v1/ticker/3j0jw7ksCqckLNRl"
    frameborder="0"
    sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox"
  ></iframe>
  <iframe
    id="nightTicker"
    src="https://rss.app/embed/v1/ticker/7ctLbFgRverm6aVX"
    frameborder="0"
    style="display: none;"
    sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox"
  ></iframe>
	<iframe
    id="mobileTicker"
    src="https://rss.app/embed/v1/ticker/w7az9T20B74RTID3"
    frameborder="0"
    sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox"
  ></iframe>
	<iframe
    id="searchTicker"
    src="https://rss.app/embed/v1/ticker/drjICgXpka7g2vRG"
    frameborder="0"
    style="display: none;"  <!-- Initially hidden until search is pressed -->
    sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox"
></iframe>
    <iframe
  id="trivagoIframeContainer"
  class="iframe-container"
  src="https://rss.app/embed/v1/ticker/z6UazOVLva9ltvNS"
  frameborder="0"
  sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox"
></iframe>


  <!-- Marker Labels (Will be dynamically generated) -->
  <div id="labels-container"></div>
  <div id="loadingIcon" class="loading-spinner"></div>
  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.136.0/build/three.module.js",
      "three/examples/jsm/controls/OrbitControls": "https://unpkg.com/three@0.136.0/examples/jsm/controls/OrbitControls.js",
      "three/examples/jsm/renderers/CSS2DRenderer": "https://unpkg.com/three@0.136.0/examples/jsm/renderers/CSS2DRenderer.js",
      "three/examples/jsm/renderers/CSS3DRenderer": "https://cdn.jsdelivr.net/npm/three@0.136.0/examples/jsm/renderers/CSS3DRenderer.js",
      "three/examples/jsm/loaders/RGBELoader": "https://unpkg.com/three@0.136.0/examples/jsm/loaders/RGBELoader.js"
    }
  }
  </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/luxon/3.3.0/luxon.min.js"></script>
<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCfIj92sJmW8WvTGAfe8cQSzgBfnAjEfDM"></script>

<script>
  // Function to toggle the visibility of the region select dropdown when clicking the button
	document.addEventListener("DOMContentLoaded", function() {
  document.getElementById('regionSelectBtn').addEventListener('click', function(event) {
    var regionSelect = document.getElementById('regionSelectDropdown');
    
    // Toggle the visibility of the dropdown
    if (regionSelect.style.display === 'block') {
      regionSelect.style.display = 'none';
    } else {
      regionSelect.style.display = 'block';
    }
    
    // Prevent the click from propagating to the document listener (so it won't hide immediately)
    event.stopPropagation();
  });

  // Function to hide the region select dropdown when clicking outside of it
  document.addEventListener('click', function(event) {
    var regionSelect = document.getElementById('regionSelectDropdown');
    var regionSelectBtn = document.getElementById('regionSelectBtn');
    
    // Check if the click happened outside the dropdown and button
    if (regionSelect && !regionSelect.contains(event.target) && !regionSelectBtn.contains(event.target)) {
      regionSelect.style.display = 'none';
    }
  });
});
</script>

<script type="x-shader/x-vertex" id="vertexShader">
  varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vp;
varying vec3 vPositionNormal;
void main(void){
  vUv = uv;
  vNormal = normalize( normalMatrix * normal );
  vp = position;
  vPositionNormal = normalize(( modelViewMatrix * vec4(position, 1.0) ).xyz);
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
  uniform vec3 glowColor;
uniform float bias;
uniform float power;
uniform float time;
varying vec3 vp;
varying vec3 vNormal;
varying vec3 vPositionNormal;
uniform float scale;

uniform sampler2D map;

varying vec2 vUv;

void main(void){
  float a = pow( bias + scale * abs(dot(vNormal, vPositionNormal)), power );
  if(vp.y > time && vp.y < time + 20.0) {
    float t =  smoothstep(0.0, 0.8,  (1.0 - abs(0.5 - (vp.y - time) / 20.0)) / 3.0  );
    gl_FragColor = mix(gl_FragColor, vec4(glowColor, 1.0), t * t );
  }
  gl_FragColor = mix(gl_FragColor, vec4( glowColor, 1.0 ), a);
  float b = 0.8;
  gl_FragColor = gl_FragColor + texture2D( map, vUv );
}
</script>
<script type="x-shader/x-vertex" id="aeroVertexShader">
  varying vec3	vVertexWorldPosition;
varying vec3	vVertexNormal;
varying vec4	vFragColor;
void main(){
vVertexNormal	= normalize(normalMatrix * normal);
vVertexWorldPosition	= (modelMatrix * vec4(position, 1.0)).xyz;
gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="aeroFragmentShader">
  uniform vec3	glowColor;
uniform float	coeficient;
uniform float	power;

varying vec3	vVertexNormal;
varying vec3	vVertexWorldPosition;

varying vec4	vFragColor;

void main(){
vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;
vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
viewCameraToVertex= normalize(viewCameraToVertex); 
float intensity	= pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);
gl_FragColor = vec4(glowColor, intensity);
}
</script>


	
<button id="toggleButton">Switch to Night</button>
<button id="newsButton">Latest Airbnbs</button>
  <!-- The iframe containers will be added dynamically -->
  <!-- X Button to close the iframe -->
<button id="closeNewsButton">×</button>
  <!-- Iframe overlay for news articles -->
<div id="newsOverlay" style="display: none;">
  <iframe id="newsIframe" width="900" height="1600" src="https://rss.app/embed/v1/magazine/5J869AE7cqDlimdE" frameborder="0"></iframe>
</div>
<div id="newsOverlaynighttheme" style="display: none;">
  <iframe id="newsIframenighttheme" width="900" height="1600" src="https://rss.app/embed/v1/magazine/l8d8McKVHYpe6MzA" frameborder="0"></iframe>
</div>
	
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const labelDiv = document.querySelector('div[style*="1324px"][style*="353px"]');
    if (labelDiv) {
      labelDiv.setAttribute('draggable', 'true');
      labelDiv.style.touchAction = 'auto';
    }
  });
</script>

  <!-- Scripts -->
  <!-- Include Three.js and other dependencies here -->

  <!-- Main JavaScript -->
  <script type="module">
    // JavaScript code will go here
    import * as THREE from "https://unpkg.com/three@0.136.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.136.0/examples/jsm/controls/OrbitControls";
  import {
    CSS2DRenderer,
    CSS2DObject,
  } from "https://unpkg.com/three@0.136.0/examples/jsm/renderers/CSS2DRenderer.js";
    import { RGBELoader } from 'https://unpkg.com/three@0.136.0/examples/jsm/loaders/RGBELoader.js';
	  // Import necessary post-processing modules
import { EffectComposer } from 'https://unpkg.com/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js?v=1';
//import { RenderPass } from 'https://unpkg.com/three@0.136.0/examples/jsm/postprocessing/RenderPass.js?v=1';
//import { UnrealBloomPass } from 'https://unpkg.com/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js?v=1';
//import  Luxon from 'https://cdnjs.cloudflare.com/ajax/libs/luxon/3.3.0/luxon.min.js'; //(if using modules)
  // Scene Setup
  const scene = new THREE.Scene();
  /*const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 1, 2000);*/
  let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
  camera.position.set(20, 0.5, 15).setLength(25);

	  // Hide the spinner after globe and scene are ready
//window.addEventListener('load', () => {
  //document.getElementById('loadingSpinner').style.display = 'none';
//});
// Function to switch between loaders
// Function to show the second loader when the page is almost done
// Function to switch from the first loader to the second loader after 5 seconds
/*function showSecondLoader() {
    const loader1 = document.getElementById("loader1");
    const loader2 = document.getElementById("loader2");

    // Hide the first loader and show the second loader
    loader1.classList.remove("active-loader");
    loader1.classList.add("inactive-loader");

    loader2.classList.remove("inactive-loader");
    loader2.classList.add("active-loader");

    // After 2 more seconds, hide the loader and show the main content
    setTimeout(hideLoader, 5000);  // Wait for 2 seconds before hiding the loader
}

// Function to hide the loader and show the main content
function hideLoader() {
    const overlay = document.getElementById("loading-overlay");

    // Add a class that triggers the fade-out
    overlay.classList.add('hidden');

    // After the fade-out is done, set display to 'none' to remove it from the document flow
    setTimeout(() => {
        overlay.style.display = 'none';

// Ensure it doesn't take up space or interfere with the layout
overlay.style.visibility = "hidden";
overlay.style.pointerEvents = "none"; 
    }, 500);  // Match the transition time in your CSS
}*/
//let daymarkerMaterial = new THREE.Color('#ff3232'); // Default to Airbnb color
//let nightmarkerMaterial = new THREE.Color('#FE8C02');
//const daymarkerMaterial = new THREE.Color('#ff3232');
let currentTicker = document.getElementById('dayTicker');
document.getElementById('themeToggle').addEventListener('change', (event) => {
  const isChecked = event.target.checked;

  const airbnbLogos = document.getElementsByClassName("logo-airbnb");
  const trivagoLogos = document.getElementsByClassName("logo-trivago");
  // Toggle search bar button style
  const searchBtn = document.getElementById('searchBtn');
  //let currentTicker = document.getElementById('dayTicker');
  if (isChecked) {
    searchBtn.classList.remove('airbnb-button');
    searchBtn.classList.add('trivago-button');
    // Hide the day ticker
    currentTicker.style.display = "none";
        currentTicker = document.getElementById("trivagoIframeContainer"); // Set current ticker to Trivago iframe
        currentTicker.style.display = "block";
    // Hide all Airbnb logos
  Array.from(airbnbLogos).forEach(logo => logo.style.display = "block");
  Array.from(trivagoLogos).forEach(logo => logo.style.display = "none");
    document.getElementById("trivagoIframeContainer").style.display = "block";
    searchBtn.style.backgroundColor = '#00aaff';
    const regionPopupButton = document.querySelector('#regionPopup button'); // Selects the button inside #regionPopup
regionPopupButton.style.backgroundColor = '#00aaff';
//daymarkerMaterial.set('#00aaff');
    searchBtn.textContent = 'Search';
  } else {
    searchBtn.classList.remove('trivago-button');
    searchBtn.classList.add('airbnb-button');
    document.getElementById("trivagoIframeContainer").style.display = "none";
    // Hide the Trivago iframe
    currentTicker.style.display = "none";
        currentTicker = document.getElementById("dayTicker"); // Set current ticker to Day ticker
        currentTicker.style.display = "block";
    Array.from(trivagoLogos).forEach(logo => logo.style.display = "block");
    Array.from(airbnbLogos).forEach(logo => logo.style.display = "none");
    searchBtn.style.backgroundColor = '#ff385c';
    //daymarkerMaterial.set('#ff3232');
    const regionPopupButton = document.querySelector('#regionPopup button'); // Selects the button inside #regionPopup
    regionPopupButton.style.backgroundColor = '#ff385c';
    searchBtn.textContent = 'Search';
  }

  // Toggle iframe containers
  //document.getElementById('dayTicker').classList.toggle('hidden', isChecked);
  //document.getElementById('trivagoIframeContainer').classList.toggle('hidden', !isChecked);
});

// Show loading screen and switch SVGs
document.addEventListener('DOMContentLoaded', () => {
  const loadingScreen = document.getElementById('loadingScreen');
  const loader1 = document.getElementById('loader1');
  const loader2 = document.getElementById('loader2');
  // Show first loader for 5 seconds
  setTimeout(() => {
    loader1.style.display = 'none';
    loader2.style.display = 'block'; // Show second loader
  }, 5000);

  // Hide loading screen after 10 seconds
  setTimeout(() => {
    loadingScreen.style.display = 'none';
  }, 10000);
});

// Show instructions after clicking the Submit Region button
document.getElementById('submitRegion').addEventListener('click', () => {
  const instructionsOverlay = document.getElementById('instructionsOverlay');
  const gotItBtn = document.getElementById('gotItBtn');

  // Show the instructions overlay
  instructionsOverlay.classList.remove('hidden');

  // Delay showing "Got It" button until instructions are shown
  setTimeout(() => {
    gotItBtn.classList.remove('hidden');
  }, 2000); // Delay for visual effect

  let currentStep = 0;
  const steps = document.querySelectorAll('.instruction-step');

  // Initially hide all steps
  steps.forEach(step => step.classList.add('hidden'));

  // Show the first step
  steps[currentStep].classList.remove('hidden');

  // Cycle through steps every 5 seconds
  const showNextStep = () => {
    steps[currentStep].classList.add('hidden');
    currentStep++;
    if (currentStep < steps.length) {
      steps[currentStep].classList.remove('hidden');
    } else {
      clearInterval(stepInterval); // Stop cycling after the last step
    }
  };

  const stepInterval = setInterval(showNextStep, 5000);

  // Close instructions when "Got It" button is clicked
  gotItBtn.addEventListener('click', () => {
    instructionsOverlay.classList.add('hidden'); // Hide instructions overlay
    gotItBtn.classList.add('hidden'); // Hide "Got It" button
    clearInterval(stepInterval); // Stop cycling steps
    controls.autoRotate = true; // Resume autorotation
    const confirmationMessage = document.getElementById('confirmationMessage');
    confirmationMessage.style.display = 'block'; // Show confirmation message

    setTimeout(() => {
      confirmationMessage.style.display = 'none';
    }, 20000); // Hide confirmation message after 20 seconds
  });
});



// Start loading process as soon as the page starts loading
// Use window.onload to ensure the script runs when the page is fully loaded
  /*window.onload = function () {
    console.log('Page loaded, showing overlay.');
    const overlay = document.getElementById('loading-overlay');

// Ensure it's visible
overlay.style.display = 'block';
overlay.style.visibility = 'visible';  // Reset visibility in case it's hidden
overlay.style.pointerEvents = 'auto'; // Allow interaction if needed

    // Show the first loader for 5 seconds, then switch to the second loader
    setTimeout(showSecondLoader, 5000);  // Wait 5 seconds before switching to the second loader
  };*/


const earthRadius = 5.1; // Adjust this to match your globe's size
const textureLoader = new THREE.TextureLoader();
const dayTexture = textureLoader.load("js/Earth_Diffuse.jpg");
const bumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");
const normalMap = textureLoader.load('js/Earth_Normal.jpg'); // Use a realistic normal map
const specularMap = textureLoader.load("js/Earth_Specular.jpg");
const earthMaterial = new THREE.ShaderMaterial({
  uniforms: {
    // Day texture, bump map, normal map, specular map, etc.
    map: { value: dayTexture },
    bumpMap: { value: bumpMap },
    normalMap: { value: normalMap },
    specularMap: { value: specularMap },
    bumpScale: { value: 0.05 },
    specularColor: { value: new THREE.Color('grey') },  // Specular color
    shininess: { value: 15 },
    // Custom uniforms for glow, scale, bias, etc.
    glowColor: { value: new THREE.Color(0x0cd1eb) },  // Glow color
    scale: { type: "f", value: -1.0 },  // Scale for glow
    bias: { type: "f", value: 1.0 },  // Bias for glow effect
    power: { type: "f", value: 3.3 },  // Power of glow intensity
    time: { type: "f", value: 0 },  // Time for animation effects
    isHover: { value: false },  // Whether the globe is being hovered over
  },
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
    });
    let globe2;
    function createEarthGlow() {
    const R = 5.099
    const texture2 = textureLoader.load("js/glow.png");

    const spriteMaterial = new THREE.SpriteMaterial({
      map: texture2,
      color: 0x4390d1,
      transparent: true,
      opacity: 1.5,
      depthWrite: false,
    });
    const sprite = new THREE.Sprite(spriteMaterial);
    sprite.scale.set(R * 3.0, R * 3.0, 1);
    globe2.add(sprite);
  };
  function createEarthAperture() {
    const AeroSphere = {
      uniforms: {
        coeficient: {
          value: 1.0,
        },
        power: {
          value: 3,
        },
        glowColor: {
          value: new THREE.Color(0x4390d1),
        },
      },
      vertexShader: document.getElementById('aeroVertexShader').textContent,
      fragmentShader: document.getElementById('aeroFragmentShader').textContent,
    };
  const apmaterial = new THREE.ShaderMaterial({
      uniforms: AeroSphere.uniforms,
      vertexShader: AeroSphere.vertexShader,
      fragmentShader: AeroSphere.fragmentShader,
      blending: THREE.NormalBlending,
      transparent: true,
      depthWrite: false,
    });
    // Setting the radius, width segments, and height segments
const sphere = new THREE.SphereGeometry(
  5.099,  // radius
  128.1,        // widthSegments
  128.1         // heightSegments
);
    const mesh = new THREE.Mesh(sphere, apmaterial);
     globe2.add(mesh);
  }


  //async function createMarkupPoint(options) {
  

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  //renderer.setSize(innerWidth, innerHeight);
  //renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);
  
  // Label Renderer
  const labelRenderer = new CSS2DRenderer();
  labelRenderer.setSize(innerWidth, innerHeight);
  labelRenderer.domElement.style.position = 'absolute';
  labelRenderer.domElement.style.top = '0px';
  document.body.appendChild(labelRenderer.domElement);
  
  // Controls
  let controls = new OrbitControls(camera, labelRenderer.domElement);
  //controls.enableZoom = true;
  controls.enablePan = false;
  //controls.enableDamping = true; // Smooth the motion
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  //controls.dampingFactor = 0.25;
  controls.enableZoom = true;
  controls.minDistance = 2.5;
  controls.maxDistance = 25;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;
  controls.enabled = true;
renderer.domElement.addEventListener('mousedown', function(event) {
    event.preventDefault(); // Prevent default behavior
    controls.enabled = true; // Enable dragging
});

renderer.domElement.addEventListener('mouseup', function() {
    controls.enabled = true; // Ensure controls are active after drag
});


   // Lighting - Reduced intensity to reduce glare
    /*const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft ambient light
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4); // Reduced intensity
    directionalLight.position.set(5, 5, 5); // Adjust position
    scene.add(directionalLight);*/
  
  // Global Uniforms
  const globalUniforms = {
    time: { value: 0 },
  };
  
  // Handle Window Resize
  window.addEventListener('resize', onWindowResize);
  
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
}
	  window.addEventListener('resize', () => {
    if (window.renderer && window.camera) {
        const newWidth = globeContainer.clientWidth;
        const newHeight = globeContainer.clientHeight;
        window.renderer.setSize(newWidth, newHeight);
        window.camera.aspect = newWidth / newHeight;
        window.camera.updateProjectionMatrix();
    }
});
let isDay = true; // Track whether it's currently day or night
	  //let dayTexture, nightTexture;
	  let rt;

	  let texture;

/*document.getElementById('newsButton').addEventListener('click', function() {
  if (isDay) {
    const newsOverlaynighttheme = document.getElementById('newsOverlaynighttheme');  
    const newsOverlay = document.getElementById('newsOverlay');

    newsOverlaynighttheme.style.display = 'flex';  // Show the night theme news overlay
    newsOverlay.style.display = 'none';  // Hide the day theme news overlay

    const closeNewsButton = document.getElementById('closeNewsButton');
    closeNewsButton.style.display = 'flex';  // Show the close button

  } else {
    const newsOverlay = document.getElementById('newsOverlay');
    const newsOverlaynighttheme = document.getElementById('newsOverlaynighttheme');

    newsOverlay.style.display = 'flex';  // Show the day theme news overlay
    newsOverlaynighttheme.style.display = 'none';  // Hide the night theme news overlay

    const closeNewsButton = document.getElementById('closeNewsButton');
    closeNewsButton.style.display = 'flex';  // Show the close button
  }

  // Toggle day/night mode
  isDay = !isDay;
}); // This closes the addEventListener function correctly
*/
	  document.getElementById('newsButton').addEventListener('click', function() {
  const newsOverlayDay = document.getElementById('newsOverlay');
  const newsOverlayNight = document.getElementById('newsOverlaynighttheme');
  const closeNewsButton = document.getElementById('closeNewsButton');
		  if (isDay) {
    // Show day theme news overlay
    newsOverlayDay.style.display = 'flex';
    newsOverlayNight.style.display = 'none';
  } else {
    // Show night theme news overlay
    newsOverlayNight.style.display = 'flex';
    newsOverlayDay.style.display = 'none';
  }

  // Display the close button in both cases
  closeNewsButton.style.display = 'flex';

	  });
		  
	
  //const selectedRegion = document.getElementById('regionSelect').value;

		  /*document.addEventListener("DOMContentLoaded", function() {
			  
  // Your existing event listeners and code go here
			  
  document.getElementById('submitRegion').addEventListener('click', function() {
  // Close the initial region popup
  document.getElementById('regionPopup').style.display = 'none';

  // Show the confirmation message
  document.getElementById('confirmationMessage').style.display = 'block';

  // Hide the confirmation message after 5 seconds
  setTimeout(function() {
    document.getElementById('confirmationMessage').style.display = 'none';
  }, 10000);
// Pan to the selected region
  panToRegion(selectedRegion);
});
});*/
	    

 /*  // Always visible region select button
  document.getElementById('regionSelectBtn').style.display = 'block';

  document.getElementById('regionSelectBtn').addEventListener('click', function() {
    // Check if dropdown already exists to avoid adding multiple
    if (!document.getElementById('regionSelectDropdown')) {
      // Create the dropdown menu with regions
      let regionSelect = document.createElement('select');
      regionSelect.id = 'regionSelectDropdown';
      regionSelect.innerHTML = `
        <option value="africa">Africa</option>
        <option value="europe">Europe</option>
        <option value="america">America</option>
        <option value="south america">South America</option>
        <option value="carribbean">Carribbean</option>
        <option value="asia">Asia</option>
	<option value="world">World</option>
      `;
      
      this.insertAdjacentElement('afterend', regionSelect);

// Ensure it's visible and styled correctly
    regionSelect.style.display = 'block';

      // Pan the camera to the selected region when changed
      regionSelect.addEventListener('change', function() {
        let selectedRegion = this.value;
        panToRegion(selectedRegion); // Call pan function with selected region
      });
    }
  });
*/
// Function to stop all existing tweens
function stopAllTweens() {
    TWEEN.getAll().forEach(function(tween) {
        tween.stop(); // Stop each tween
    });
}/*
  // Function to pan the camera to the selected region
  // Function to pan the camera to the selected region
	function panToRegion(region) {
    let position;
    let zoomLevel;

    // Reset zoom to default value before transitioning
    camera.zoom = 1;
    camera.updateProjectionMatrix(); // Apply the reset zoom value

    switch (region) {
        case 'africa':
            position = { x: 12.0, y: 0, z: 1.74 }; // Increased the x-value to move further right
            zoomLevel = 1.5; // Adjust zoom level as needed
            break;
        case 'europe':
            // Moved slightly to the right (increase in x) and zoomed in more
            position = { x: 3.5, y: 2.91, z: 0.55 }; // Shifted right
            zoomLevel = 2.0; // Slightly more zoomed in
            break;
        case 'america':
            position = { x: 0, y: 2.55, z: 4.42 };
            zoomLevel = 2.0;
            break;
        case 'south america':
            position = { x: 1.5, y: -0.5, z: 4.3 }; // Increased x value to move further right
            zoomLevel = 1.7;
            break;
        case 'carribbean':
            position = { x: 0.65, y: 2.0, z: 4.6 }; // Adjusted for Caribbean
            zoomLevel = 2.4;
            break;
        case 'asia':
            position = { x: -0.89, y: 3.28, z: -3.92 };
            zoomLevel = 1.9;
            break;
        case 'world':
            position = { x: 0, y: 0, z: 10 }; // Zoomed-out, general view of the world
            zoomLevel = 0.5; // Reduced zoom level to show the entire Earth
            break;
        default:
            console.log('Region not recognized');
            return;
    }

    // Stop auto-rotation after panning
    controls.autoRotate = false;

    // Animate camera panning and zooming
    animateCameraPan(position.x, position.y, position.z, zoomLevel);
}

function animateCameraPan(x, y, z, zoomLevel) {
    new TWEEN.Tween(camera.position)
        .to({ x: x, y: y, z: z }, 2000) // Smoothly pan over 2 seconds
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onUpdate(function () {
            camera.lookAt(0, 0, 0);
        })
        .start();

    // Add zooming to the pan
    new TWEEN.Tween(camera)
        .to({ zoom: zoomLevel }, 2000) // Adjust zoom over the same duration
        .easing(TWEEN.Easing.Quadratic.InOut)
        .onUpdate(function () {
            camera.updateProjectionMatrix(); // Important to update the camera matrix for zoom to take effect
        })
        .onComplete(function () {
            // After zoom and panning complete, restart slow auto-rotation
            setTimeout(function () {
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.25; // Slow rotation speed
            }, 500);
        })
        .start();
}*/
//const earthRadius = 5.1; // Adjust this to match your globe's size
//const textureLoader = new THREE.TextureLoader();

	  /*const cloudTexture2 = textureLoader.load("js/Earth_Cloud.jpg");
	  const cloudGeometry = new THREE.SphereGeometry(earthRadius * 1.005, 64, 64);
const cloudMaterial2 = new THREE.MeshPhongMaterial({
  map: cloudTexture2, // Use a high-quality cloud texture with transparency
  transparent: true,
  opacity: 0.4 // Adjust for subtle effect
});
const cloudMesh2 = new THREE.Mesh(cloudGeometry, cloudMaterial2);
scene.add(cloudMesh2);
function animateClouds() {
    cloudMesh2.rotation.y += 0.001; // Adjust rotation speed
    requestAnimationFrame(animateClouds);
}
animateClouds();*/

	  
/*document.getElementById('searchBtn').addEventListener('click', () => {
  const where = document.getElementById('where').value;
  const when = document.getElementById('when').value;
  const guests = document.getElementById('guests').value;

  // Show results iframe
  const iframeSrc = generateAirbnbUrl(where, when, guests);
  document.getElementById('resultsIframe').src = iframeSrc;

  // Adjust layout
  document.getElementById('content').style.display = 'flex';
});*/

/*function generateAirbnbUrl(where, when, guests) {
  return `https://www.airbnb.com/s/${where}/homes?checkin=${when}&guests=${guests}`;
}
  function loadMarkersForRegion(region) {
  const markersData = getMarkersDataForRegion(region);
  markersData.forEach(marker => {
    addMarkerToGlobe(marker);
  });
}*/

	 /* document.getElementById('newsButton').addEventListener('click', function() {
  const newsOverlay = document.getElementById('newsOverlay');
  newsOverlay.style.display = 'flex';  // Show the news iframe
const closeNewsButton = document.getElementById('closeNewsButton');
  closeNewsButton.style.display = 'flex';  // Show the news iframe
});*/

document.getElementById('closeNewsButton').addEventListener('click', function() {
  document.getElementById('newsOverlay').style.display = 'none';  // Close the news iframe
document.getElementById('newsOverlaynighttheme').style.display = 'none';
document.getElementById('closeNewsButton').style.display = 'none';  // Close the news iframe
});
	  // Function to close the news overlay when clicking outside the iframe
function closeNewsOverlayOnClick(event) {
  const newsOverlay = document.getElementById('newsOverlay');
  const newsIframe = document.getElementById('newsIframe');

  // Check if the click was outside the news overlay iframe
  if (newsOverlay.style.display === 'block' && !newsIframe.contains(event.target)) {
    newsOverlay.style.display = 'none'; // Hide the overlay
  }
}

// Function to close the night theme overlay
function closeNewsOverlayNightOnClick(event) {
  const newsOverlayNight = document.getElementById('newsOverlaynighttheme');
  const newsIframeNight = document.getElementById('newsIframenighttheme');

  // Check if the click was outside the night theme overlay iframe
  if (newsOverlayNight.style.display === 'block' && !newsIframeNight.contains(event.target)) {
    newsOverlayNight.style.display = 'none'; // Hide the night theme overlay
  }
}

// Add event listeners to close overlays when clicking outside
document.addEventListener('click', closeNewsOverlayOnClick);
document.addEventListener('click', closeNewsOverlayNightOnClick);


	  
const cloudTexture = new THREE.TextureLoader().load('https://mrdoob.com/lab/javascript/webgl/clouds/cloud10.png')
  const cloudMaterial = new THREE.ShaderMaterial({
  uniforms: {
    cloudTexture: { type: 't', value: cloudTexture }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D cloudTexture;
    varying vec2 vUv;
    void main() {
      vec4 textureColor = texture2D(cloudTexture, vUv);
      textureColor.a *= 0.9;  // Adjust opacity
      gl_FragColor = vec4(textureColor.rgb, textureColor.a);
    }
  `,
  transparent: true
});

// Create geometry and apply the shader material
const cloudGeo = new THREE.PlaneGeometry(800, 800);
const cloudMesh = new THREE.Mesh(cloudGeo, cloudMaterial);

// Position the clouds in the scene
//cloudMesh.position.set(-100, -100, -500);// Add clouds after texture is loaded
//cloudMesh.position.set(-200, -100, -700);// Add clouds after texture is loaded
  cloudMesh.position.set(-700, -100, -1000);// Add clouds after texture is loaded
// const daymarkerMaterial = '#ff3232';
 // const nightmarkerMaterial = '#FE8C02';
	  //const daymarkerMaterial = new THREE.Color('#ff3232');
//const nightmarkerMaterial = new THREE.Color('#FE8C02');
	  const daymarkerMaterial = new THREE.Color('#ff3232');
const nightmarkerMaterial = new THREE.Color('#FE8C02');
	  //const daymarkerMaterial = new THREE.Color('#00FF00');
//const nightmarkerMaterial = new THREE.Color('#FFFFFF');

const markerMaterial2 = new THREE.MeshBasicMaterial({
    color: daymarkerMaterial,
    onBeforeCompile: (shader) => {
      shader.uniforms.time = globalUniforms.time;
      shader.vertexShader = `
      	attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
        	vPhase = phase; // de-synch of ripples
        `
      );
      shader.fragmentShader = `
      	uniform float time;
        varying float vPhase;
      	${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });
  markerMaterial2.defines = { USE_UV: '' };

    // Track loaded textures
let texturesLoaded = 0;
const totalTextures = 4; // Update this if you have more or fewer textures

function checkTexturesLoaded() {
  texturesLoaded++;
  if (texturesLoaded === totalTextures) {
    animate(); // Start animation after all textures are loaded
  }
}
	   // Check if the user is on a mobile device
    if (window.innerWidth <= 768) {  // This checks for mobile devices based on screen width
        camera.position.set(20, 0.5, 15).setLength(20);     // Set the camera's z position to 25 for mobile device
        document.getElementById('header').style.display = 'none';
    } else {
        camera.position.set(20, 0.5, 15).setLength(16);    // Default z position for desktop or larger screens
        //document.getElementById('header').style.display = 'block';
    }
	  
    //let dayTexture, nightTexture;
    //let isDay = true; // Track whether it's currently day or night

// Load Textures
//const textureLoader = new THREE.TextureLoader();

// Background Texture
   /* const loader = new THREE.TextureLoader();
loader.load('textures/TCom_Aerials0006_3_L.jpg', function (texture) {
  const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
  rt.fromEquirectangularTexture(renderer, texture);
  //scene.background = rt.texture;
});*/

	  // Load the Cube Map
      const cubeTextureLoader = new THREE.CubeTextureLoader();
	  const isMobile = /Mobi/i.test(navigator.userAgent);

/*const cubeMap = cubeTextureLoader.load([
  isMobile ? 'js/px.webp' : 'js/px.png', // Right face
  isMobile ? 'js/nx.webp' : 'js/nx.png', // Left face
  isMobile ? 'js/py.webp' : 'js/py.png', // Top face
  isMobile ? 'js/ny.webp' : 'js/ny.png', // Bottom face
  isMobile ? 'js/pz.webp' : 'js/pz.png', // Front face
  isMobile ? 'js/nz.webp' : 'js/nz.png'  // Back face
]);*/
	  // Load Cube Maps for Background
    //const cubeTextureLoader = new THREE.CubeTextureLoader();
   /* const dayCubeMap = cubeTextureLoader.load([
     isMobile ? 'js/px.webp' : 'js/px.png', // Right face
  isMobile ? 'js/nx.webp' : 'js/nx.png', // Left face
  isMobile ? 'js/py.webp' : 'js/py.png', // Top face
  isMobile ? 'js/ny.webp' : 'js/ny.png', // Bottom face
  isMobile ? 'js/pz.webp' : 'js/pz.png', // Front face
  isMobile ? 'js/nz.webp' : 'js/nz.png'  // Back face
    ]);
	  const dayCubeMap2 = cubeTextureLoader.load([
     isMobile ? 'textures/px___(1).webp' : 'textures/px___(1).png', // Right face
  isMobile ? 'textures/py___(1).webp' : 'textures/py___(1).png', // Left face
  isMobile ? 'textures/py___(1).webp' : 'textures/py___(1).png', // Top face
  isMobile ? 'textures/ny___(1).webp' : 'textures/ny___(1).png', // Bottom face
  isMobile ? 'textures/pz___(1).webp' : 'textures/pz___(1).png', // Front face
  isMobile ? 'textures/nz___(1).webp' : 'textures/nz___(1).png'  // Back face
    ]);
    const nightCubeMap = cubeTextureLoader.load([
      isMobile ? 'js/px_(1).webp' : 'textures/px_(1).png', // Right face
  isMobile ? 'js/nx_(1).webp' : 'textures/nx_(1).png', // Left face
  isMobile ? 'js/py_(1).webp' : 'textures/py_(1).png', // Top face
  isMobile ? 'js/ny_(1).webp' : 'textures/ny_(1).png', // Bottom face
  isMobile ? 'js/pz_(1).webp' : 'textures/pz_(1).png', // Front face
  isMobile ? 'js/nz_(1).webp' : 'textures/nz_(1).png'  // Back face
    ]);*/
	  /*const nightCubeMap = cubeTextureLoader.load([
      isMobile ? 'js/px (1).webp' : 'js/px (1).png', // Right face
  isMobile ? 'js/nx (1).webp' : 'js/nx (1).png', // Left face
  isMobile ? 'js/py (1).webp' : 'js/py (1).png', // Top face
  isMobile ? 'js/ny (1).webp' : 'js/ny (1).png', // Bottom face
  isMobile ? 'js/pz (1).webp' : 'js/pz (1).png', // Front face
  isMobile ? 'js/nz (1).webp' : 'js/nz (1).png'  // Back face
    ]);*/

    // Set Initial Background Cube Map
   // scene.background = dayCubeMap;
   // scene.background = new THREE.Color(0x87CEEB); // Light sky blue
	 // Create a gradient for the daytime scene background
const canvas = document.createElement('canvas');
canvas.width = 1024;
canvas.height = 1024;

const context = canvas.getContext('2d');

// Create gradient from light sky blue to deep space blue
const gradient = context.createRadialGradient(512, 512, 100, 512, 512, 512);
gradient.addColorStop(0, '#87CEEB');  // Light sky blue near Earth
gradient.addColorStop(1, '#4682B4');  // Deep space blue at edges
context.fillStyle = gradient;
context.fillRect(0, 0, canvas.width, canvas.height);

// Create a texture from the canvas
const daybackgroundTexture = new THREE.CanvasTexture(canvas);

// Create a gradient for the night scene background
const canvas2 = document.createElement('canvas');
canvas2.width = 1024;
canvas2.height = 1024;

const context2 = canvas2.getContext('2d');  // Use the correct 'canvas2'

// Create gradient from dark blue to slightly lighter blue
const gradient2 = context2.createRadialGradient(512, 512, 100, 512, 512, 512);
gradient2.addColorStop(0, '#000033');  // Darker blue (center near Earth)
gradient2.addColorStop(1, '#000066');  // Slightly lighter blue for edges (space)
context2.fillStyle = gradient2;
context2.fillRect(0, 0, canvas2.width, canvas2.height);

// Create a texture from the canvas
const nightbackgroundTexture = new THREE.CanvasTexture(canvas2);
	  // Load Textures
  //const textureLoader = new THREE.TextureLoader();
  //const dayTexture = textureLoader.load("//unpkg.com/three-globe/example/img/earth-blue-marble.jpg");
	 //const dayTexture = textureLoader.load("js/Earth_Diffuse.jpg");
//const dayTexture = textureLoader.load("https://github.com/Shange-Fagan/Airbnb-Assistant/releases/download/pictures_for_earth_texture_high_res/world_shaded_43k.jpg");
    //const dayTexture = textureLoader.load("textures/earth-blue-marble-with-clouds.jpeg");
//const dayTexture = textureLoader.load("textures/8k_earth_daymap.jpg");
  //const nightTexture = textureLoader.load("//unpkg.com/three-globe/example/img/earth-night.jpg");
	  const nightTexture = textureLoader.load("//unpkg.com/three-globe/example/img/earth-night.jpg");
	  //const nightTexture = textureLoader.load("https://github.com/Shange-Fagan/Airbnb-Assistant/releases/download/pictures_for_earth_texture/earth-night-16k.jpg");
	  //const nightTexture = textureLoader.load("js/8k_earth_nightmap.jpg");
  //const bumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");
  //const specularMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-water.png");
	  //const specularMap = textureLoader.load("js/Earth_Specular.jpg");
const dayBumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");
	  //const normalMap = textureLoader.load('js/Earth_Normal.jpg'); // Use a realistic normal map
const nightBumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");

	  //const textureLoader = new THREE.TextureLoader();

// Load the texture
/*const dayTexture = textureLoader.load(
  'js/Earth_Diffuse.jpg',
  function (texture) {
    console.log('Texture loaded successfully');
  },
  undefined,
  function (err) {
    console.error('An error occurred loading the texture: ', err);
  }
);*/


// Ensure correct wrapping
dayTexture.wrapS = THREE.ClampToEdgeWrapping;
dayTexture.wrapT = THREE.ClampToEdgeWrapping;

// Use appropriate filtering
dayTexture.minFilter = THREE.LinearFilter; // Smooths texture when zoomed
dayTexture.magFilter = THREE.LinearFilter;
dayTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Increases texture quality at glancing angles


	  // Ensure correct wrapping
nightTexture.wrapS = THREE.ClampToEdgeWrapping;
nightTexture.wrapT = THREE.ClampToEdgeWrapping;

// Use appropriate filtering
nightTexture.minFilter = THREE.LinearFilter;
nightTexture.magFilter = THREE.LinearFilter;
nightTexture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // Increases texture quality at glancing angles

  
	  const shaderMaterial2 = new THREE.ShaderMaterial({
  uniforms: {
    dayTexture: { type: 't', value: dayTexture },
    nightTexture: { type: 't', value: nightTexture },
    transition: { value: 0 } // 0 for day, 1 for night
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D dayTexture;
    uniform sampler2D nightTexture;
    uniform float transition; // Smooth transition factor
    varying vec2 vUv;
    void main() {
      vec4 day = texture2D(dayTexture, vUv);
      vec4 night = texture2D(nightTexture, vUv);
      gl_FragColor = mix(day, night, transition);
    }
  `,
});

	// Set the background of the scene
        scene.add(cloudMesh);
	scene.background = daybackgroundTexture;
// Toggle between Day/Night Textures and Cube Map
   /* function toggleDayNight() {
      if (isDay) {
	        // Check if the user is on a mobile device
    if (window.innerWidth <= 768) {  // This checks for mobile devices based on screen width
        document.getElementById("nightTicker").style.display = "none";
	    document.getElementById("dayTicker").style.display = "none";
	    document.getElementById("mobileTicker").style.display = "block";
	    // Set the transition to night
        new TWEEN.Tween(shaderMaterial2.uniforms.transition)
        .to({ value: 1 }, 20000)  // Smooth transition over 2 seconds
        .start();
        globe2.material.map = nightTexture;
      //scene.background = nightCubeMap;
        // Set a dark blue color for the night theme background
        //scene.background = new THREE.Color(0x000033); // Dark blue
      scene.background = nightbackgroundTexture;
	//scene.add(starField); // Add stars for the night
        scene.remove(cloudMesh); // Remove clouds for night
        markerMaterial.color.set(nightmarkerMaterial);
        document.getElementById("toggleButton").textContent = "Switch to Day";
    } else {
        // Set the transition to night
         new TWEEN.Tween(shaderMaterial2.uniforms.transition)
         .to({ value: 1 }, 20000)  // Smooth transition over 2 seconds
         .start();
        globe2.material.map = nightTexture;
      //scene.background = nightCubeMap;
        // Set a dark blue color for the night theme background
        //scene.background = new THREE.Color(0x000033); // Dark blue
      scene.background = nightbackgroundTexture;
	//scene.add(starField); // Add stars for the night
        scene.remove(cloudMesh); // Remove clouds for night
        markerMaterial.color.set(nightmarkerMaterial);
        document.getElementById("toggleButton").textContent = "Switch to Day";
        document.getElementById("dayTicker").style.display = "none";
        document.getElementById("nightTicker").style.display = "block";
	    	document.getElementById("mobileTicker").style.display = "none";

    }
        
      } else {
	      // Check if the user is on a mobile device
    if (window.innerWidth <= 768) {  // This checks for mobile devices based on screen width
        document.getElementById("nightTicker").style.display = "none";
	    document.getElementById("dayTicker").style.display = "none";
	    document.getElementById("mobileTicker").style.display = "block";
	    // Set the transition to day
        new TWEEN.Tween(shaderMaterial2.uniforms.transition)
        .to({ value: 0 }, 20000)  // Smooth transition over 2 seconds
        .start();
        globe2.material.map = dayTexture;
        //scene.background = dayCubeMap;
        // Set a solid blue color for the background
        //scene.background = new THREE.Color(0x87CEEB); // Light sky blue
	scene.background = daybackgroundTexture;
	//scene.remove(starField); // Remove stars in the day
        scene.add(cloudMesh); // Add clouds back for day
        markerMaterial.color.set(daymarkerMaterial);
        document.getElementById("toggleButton").textContent = "Switch to Night";
    } else {
	// Set the transition to day
        new TWEEN.Tween(shaderMaterial2.uniforms.transition)
        .to({ value: 0 }, 20000)  // Smooth transition over 2 seconds
        .start();
        globe2.material.map = dayTexture;
        //scene.background = dayCubeMap;
        // Set a solid blue color for the background
        //scene.background = new THREE.Color(0x87CEEB); // Light sky blue
	scene.background = daybackgroundTexture;
	//scene.remove(starField); // Remove stars in the day
        scene.add(cloudMesh); // Add clouds back for day
        markerMaterial.color.set(daymarkerMaterial);
        document.getElementById("toggleButton").textContent = "Switch to Night";
        document.getElementById("dayTicker").style.display = "block";
        document.getElementById("nightTicker").style.display = "none";
	document.getElementById("mobileTicker").style.display = "none";
		}
      }
      globe2.material.needsUpdate = true;
      isDay = !isDay;
    }

	// Add Event Listener to the Toggle Button
	    document.getElementById('toggleButton').addEventListener('click', toggleDayNight);
*/
	  function toggleDayNight() {
  // Ensure `isDay` is properly toggled
  if (isDay) {
    // Switching from Day to Night
    if (window.innerWidth <= 768) {  // Mobile device
      document.getElementById("nightTicker").style.display = "none";
      document.getElementById("dayTicker").style.display = "none";
      document.getElementById("mobileTicker").style.display = "block";
    } else {  // Desktop
      document.getElementById("dayTicker").style.display = "none";
      //document.getElementById("nightTicker").style.display = "block";
      console.log("Switching to Night Mode");
        if (currentTicker === document.getElementById("dayTicker")) {
            currentTicker.style.display = "block"; // Keep the current ticker visible
        }
      document.getElementById("mobileTicker").style.display = "none";
    }

    // Smooth transition to night
    new TWEEN.Tween(shaderMaterial2.uniforms.transition)
      .to({ value: 1 }, 20000)  // Smooth transition over 20 seconds
      .start();

      function createStars() {
  const vertices = [];
    const colors = [];

    for (let i = 0; i < 500; i++) {
        const vertex = new THREE.Vector3();
        vertex.x = 800 * Math.random() - 300;
        vertex.y = 800 * Math.random() - 300;
        vertex.z = 800 * Math.random() - 300;
        vertices.push(vertex.x, vertex.y, vertex.z);

        // Adding white color for each vertex
        const color = new THREE.Color(1, 1, 1);
        colors.push(color.r, color.g, color.b);
    }

    // Create a buffer geometry for the stars
    const around = new THREE.BufferGeometry();
    around.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
    around.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));
    // Create a material for the stars
    const aroundMaterial = new THREE.PointsMaterial({
        size: 2,
        sizeAttenuation: true,  // Enable size attenuation
        color: 0x4d76cf,        // Blue shade
        transparent: true,
        opacity: 1,
        map: new THREE.TextureLoader().load('js/gradient.png', () => {
    console.log('Gradient texture loaded directly');
  }) // Ensure texture is available in your context
    });

    // Create the Points object
    const aroundPoints = new THREE.Points(around, aroundMaterial);
    aroundPoints.name = "星空";  // 'Starry sky' in Chinese
    aroundPoints.scale.set(1, 1, 1);
    scene.add(aroundPoints);
  }
    // Update globe and scene for night
    //globe2.material.map = nightTexture;
    earthMaterial.uniforms.map.value = nightTexture;
    scene.background = nightbackgroundTexture;
    scene.remove(cloudMesh);  // Remove clouds for night
    //createStars();
    //scene.add(aroundPoints);

  //markerMaterial.color.set(nightmarkerMaterial);
  markerMaterial.color.set(nightmarkerMaterial);

    // Update button text to switch back to Day
    document.getElementById("toggleButton").textContent = "Switch to Day";
  } else {
    // Switching from Night to Day
    if (window.innerWidth <= 768) {  // Mobile device
      document.getElementById("nightTicker").style.display = "none";
      document.getElementById("dayTicker").style.display = "none";
      document.getElementById("mobileTicker").style.display = "block";
    } else {  // Desktop
      //document.getElementById("dayTicker").style.display = "block";
      console.log("Switching to Day Mode");
        if (currentTicker === document.getElementById("dayTicker")) {
            currentTicker.style.display = "block"; // Keep the current ticker visible
        }
      document.getElementById("nightTicker").style.display = "none";
      document.getElementById("mobileTicker").style.display = "none";
    }

    // Smooth transition to day
    new TWEEN.Tween(shaderMaterial2.uniforms.transition)
      .to({ value: 0 }, 20000)  // Smooth transition over 20 seconds
      .start();

    // Update globe and scene for day
    earthMaterial.uniforms.map.value = dayTexture;
    //globe2.material.map = dayTexture;
    scene.background = daybackgroundTexture;
    scene.add(cloudMesh);  // Add clouds for day
  markerMaterial.color.set(daymarkerMaterial);

    // Update button text to switch back to Night
    document.getElementById("toggleButton").textContent = "Switch to Night";
  }

  // Ensure globe material updates
  //globe2.material.needsUpdate = true;
  earthMaterial.needsUpdate = true;

  // Toggle the `isDay` state after the transition
  isDay = !isDay
  //updateTheme(isDay);
}
// Add Event Listener to the Toggle Button
document.getElementById('toggleButton').addEventListener('click', toggleDayNight);
//document.getElementById('toggleButton').addEventListener('click', () => {
    //isDay = !isDay; // Toggle the state
    //toggleDayNight(isDay); // Update theme based on new state
//});
//const { DateTime } = luxon;

  // Function to determine if it's day or night based on current time
//function checkDayNight() {
    //const currentTime = DateTime.now(); // Get current time in user's local timezone
    //const hour = currentTime.hour;

    // Assuming day is between 6 AM and 6 PM
    //return hour >= 6 && hour < 18;
//}

// Set initial `isDay` state based on Luxon
//isDay = checkDayNight();
//toggleDayNight(isDay); // Call your function to apply the initial theme

		/*// Load Textures
  //const textureLoader = new THREE.TextureLoader();
  const dayTexture = textureLoader.load("//unpkg.com/three-globe/example/img/earth-blue-marble.jpg");
  const nightTexture = textureLoader.load("//unpkg.com/three-globe/example/img/earth-night.jpg");
  const bumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");
  const specularMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-water.png");
const dayBumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");
const nightBumpMap = textureLoader.load("//unpkg.com/three-globe/example/img/earth-topology.png");
  */
  // Globe Material
	const sphereWidth = earthRadius;
  const sphereHeight = 128.1;
  const sphereDepth = 128.1;
  const geometry = new THREE.SphereGeometry(
    sphereWidth,
    sphereHeight,
    sphereDepth
  );

  const sphereWidth2 = 5.099;
  const sphereHeight2 = 128.1;
  const sphereDepth2 = 128.1;
  const geometry2 = new THREE.SphereGeometry(
    sphereWidth2,
    sphereHeight2,
    sphereDepth2
  );
  //const textureLoader = new THREE.TextureLoader();
  const shaderMaterial = new THREE.ShaderMaterial({});

  const material = new THREE.ShaderMaterial({
    vertexShader: `
                varying vec2 vertexUV;
                varying vec3 vertexNormal;
                   void main() {
                        vertexUV = uv;
                        vertexNormal = normalize(normalMatrix * normal);
                       gl_Position = projectionMatrix
                       * modelViewMatrix
                       * vec4(position, 1);
                     }
                    `,
    fragmentShader: `
                    uniform sampler2D globeTexture;
                    uniform sampler2D bumpMap;
                    uniform sampler2D bumpScale;
                    uniform sampler2D specularMap;
                    uniform sampler2D specular;
                    uniform sampler2D shininess;
                    varying vec2 vertexUV;
                    varying vec3 vertexNormal;
                     void main() {
                     float intensity = 1.05 - dot(
                     vertexNormal, vec3(0, 0, 1.0));
                     vec3 atmosphere = (vec3(0.3, 0.6, 1.0))
                     * pow(intensity, 1.5);
                        gl_FragColor = vec4(atmosphere +texture2D(globeTexture, vertexUV).xyz, 1.0),
                         vec4(atmosphere +texture2D(bumpMap, vertexUV).xyz, 2.0);
                     }
                    `,

    uniforms: {
      /*"color": { value: new THREE.Color( 0xffffff ) },
  			"diffuse": { value: new THREE.Color( 0xffffff ) },*/
      specular: { value: new THREE.Color("grey") },
      /*"emissive": { value: new THREE.Color( 0x000000 ) },
  			"opacity": { value: 1 },*/
      shininess: { value: 15 },
      bumpMap: {
        value: new THREE.TextureLoader().load(
          "//unpkg.com/three-globe/example/img/earth-topology.png"
        ),
      },

      bumpScale: {
        value: 0,
      },

      specularMap: {
        value: new THREE.TextureLoader().load(
          "//unpkg.com/three-globe/example/img/earth-water.png"
        ),
      },
      globeTexture: {
        value: "",
      },
      /*bump: {
                          value: new THREE.TextureLoader().load("//unpkg.com/three-globe/example/img/earth-topology.png")
                          }*/
    },
  });

  /*const atmosphere = new THREE.Mesh(
    new THREE.SphereGeometry(5.1, 128.1, 128.1),
    new THREE.ShaderMaterial({
      vertexShader: `
                varying vec3 vertexNormal;
                   void main() {
                        vertexNormal = normalize(normalMatrix * normal);
                       gl_Position = projectionMatrix
                       * modelViewMatrix
                       * vec4(position, 1);
                     }
                    `,
      fragmentShader: `
                varying vec3 vertexNormal;
                    void main() {
                    float intensity = pow(0.6 - dot(
                     vertexNormal, vec3(0, 0, 1.0)), 2.0);
                     gl_FragColor = vec4(0.3, 0.6, 1.0, 1.0) * intensity;
                    }
                    `,
	    //transparent: true, 
      blending: THREE.AdditiveBlending,
      side: THREE.BackSide,
    })
  );
	  
	atmosphere.scale.set(1, 1, 1);	
	  */
  const material2 = new THREE.MeshPhongMaterial({
  //specular: 0x111111,
  //shininess: 5,
  shininess: 15,
  map: dayTexture, // Start with day texture
  specularMap: specularMap,
  bumpMap: dayBumpMap, // Start with day bump map
  bumpScale: 0.05,
normalMap: normalMap,
  blending: THREE.AdditiveBlending,
  /*specular: 0x222222,*/
  specular: new THREE.Color('grey'), // Color of reflection, subtle for realism
});
	  let globe = new THREE.Mesh(geometry2, material);
  //let globe2 = new THREE.Mesh(geometry, material2);
  /*scene.add(atmosphere);*/
  scene.add(globe);
  //scene.add(globe2);



/*const genericMarkers = [
  { id: 1, position: [5.1, 1.2, 1.5], region: 'africa' },
  { id: 2, position: [5.1, 0.7, 1.8], region: 'europe' },
  { id: 3, position: [5.1, 0.9, 0], region: 'america' },
  { id: 4, position: [5.1, 1.6, 0.4], region: 'south america' },
  { id: 5, position: [5.1, 1, 2.3], region: 'middle east' },
  { id: 6, position: [5.1, 0.9, 3], region: 'asia' },
  { id: 7, position: [5.1, 0.9, 4], region: 'japan' },
  { id: 8, position: [5.1, 1.2, 0.2], region: 'carribbean' },
  { id: 9, position: [5.1, 0.6, 1.45], region: 'uk' },
];

// Initialize the globe and markers
function initGlobe() {
  //scene = new THREE.Scene();
  //camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
  //camera.position.set(0, 0, 20); // Adjust camera distance as needed

  //renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('globe-container').appendChild(renderer.domElement);

  /*const controls = new OrbitControls(camera, labelRenderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.25;
  controls.enableZoom = true;
  controls.minDistance = 15;
  controls.maxDistance = 25;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;*/

  // Create globe geometry and material
  //const globeGeometry = new THREE.SphereGeometry(5, 64, 64);
  //const textureLoader = new THREE.TextureLoader();
  //const globeMaterial = new THREE.MeshBasicMaterial({
    //map: textureLoader.load('js/Earth_Diffuse.jpg'),
  //});

  /*globe2 = new THREE.Mesh(geometry, material2);
  scene.add(globe2);

  // Load and display generic markers
  loadGenericMarkers();

  // Start the animation loop
  //animate();
}
// Function to load generic markers
// Function to load generic markers
function loadGenericMarkers() {

  // Marker material with custom shader for ripple effect
  const markerMaterial = new THREE.MeshBasicMaterial({
    color: daymarkerMaterial, // Ensure this color is defined
    onBeforeCompile: (shader) => {
      // Add custom uniform for time
      shader.uniforms.time = globalUniforms.time; // Ensure globalUniforms.time is defined

      // Modify vertex shader to include the phase attribute
      shader.vertexShader = `
        attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
          vPhase = phase; // de-synch of ripples
        `
      );

      // Modify fragment shader to create ripple effects based on time
      shader.fragmentShader = `
        uniform float time;
        varying float vPhase;
        ${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });

  // Define UV usage for the marker material
  markerMaterial.defines = { USE_UV: '' };

  // Marker geometry (planar markers with custom shader)
  const markerGeometry = new THREE.PlaneGeometry(0.2, 0.2); // Adjust size as needed

  // Create the instanced mesh for markers
  const markerCount = genericMarkers.length;
  const markerMesh = new THREE.InstancedMesh(markerGeometry, markerMaterial, markerCount);

  // Dummy object for setting transformations per instance
  const dummy = new THREE.Object3D();

  // Add phase array for random ripple timing per marker
  const phaseArray = [];

  // Loop through markers and set position/rotation/scale for each instance
  genericMarkers.forEach((marker, index) => {
    const [x, y, z] = marker.position;

    // Set position using spherical coordinates
    dummy.position.set(x, y, z);
  
    // Make the marker face outward from the globe (normal vector)
    dummy.lookAt(dummy.position.clone().normalize().multiplyScalar(5)); // Assuming radius 5 for the globe

    // Apply the transformation to the dummy
    dummy.updateMatrix();

    // Set matrix for the instanced mesh
    markerMesh.setMatrixAt(index, dummy.matrix);

    // Assign a random phase for ripple timing
    phaseArray.push(Math.random());
  });

  // Add phase attribute to the geometry
  markerGeometry.setAttribute('phase', new THREE.InstancedBufferAttribute(new Float32Array(phaseArray), 1));

  // Add markers to the scene
  scene.add(markerMesh);
};
	  // Function to clear existing markers
function clearExistingMarkers() {
  const markers = globe2.children.filter(obj => obj.name && obj.name.startsWith('marker-'));

  markers.forEach(marker => {
    // Dispose of the geometry and material to free up memory
    if (marker.geometry) marker.geometry.dispose();
    if (marker.material) {
      // If the material is an array (multi-material), dispose each
      if (Array.isArray(marker.material)) {
        marker.material.forEach(mat => mat.dispose());
      } else {
        marker.material.dispose();
      }
    }
    globe2.remove(marker);  // Remove the marker from the scene
  });
}

// Function to load detailed markers for a specific region
function loadDetailedMarkers(regionCoordinates) {
	// Clear existing markers if needed
  clearExistingMarkers();

  const detailedMarkers = getDetailedMarkersForRegion(regionCoordinates); // Get detailed markers
  detailedMarkers.forEach(marker => {
    const [x, y, z] = marker.position;
    const markerGeometry = new THREE.PlaneGeometry(0.1, 0.1);  // Flat marker
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide }); // Green for detailed markers
    const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
    markerMesh.position.set(x, y, z);
    globe2.add(markerMesh);
  });
}
	

// Example: Get detailed markers for a region (dummy data)
function getDetailedMarkersForRegion(regionCoordinates) {
  return [
    { id: 101, position: [regionCoordinates.lat + 0.1, regionCoordinates.lon + 0.1, 1.5] },
    { id: 102, position: [regionCoordinates.lat + 0.2, regionCoordinates.lon + 0.2, 1.8] },
  ];
}

// Pan globe to a region
function panGlobeToRegion(regionCoordinates) {
  if (camera && controls) {
    const { x, y, z } = latLonToVector3(regionCoordinates.lat, regionCoordinates.lon, 20);
    camera.position.set(x, y, z);
    controls.update();

    // Load detailed markers for the searched region
    loadDetailedMarkers(regionCoordinates);
  } else {
    console.error('Camera or controls not initialized.');
  }
}

// Convert latitude and longitude to 3D vector coordinates
function latLonToVector3(lat, lon, radius) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);
  const x = -(radius * Math.sin(phi) * Math.cos(theta));
  const y = radius * Math.cos(phi);
  const z = radius * Math.sin(phi) * Math.sin(theta);
  return { x, y, z };
}
// Placeholder for getRegionCoordinates function
function getRegionCoordinates(region) {
  const regions = {
    africa: { lat: 10, lon: 20 },
    europe: { lat: 50, lon: 10 },
    america: { lat: 40, lon: -100 },
    'south america': { lat: -10, lon: -55 },
    carribbean: { lat: 20, lon: -75 },
    asia: { lat: 30, lon: 100 },
    world: { lat: 0, lon: 0 },
  };
  return regions[region] || { lat: 0, lon: 0 };  // Default to world
}*/
	  // Markers Data
const markersData = [
  // Each marker has [radius, phi, theta] format for spherical positioning
  { id: 1, region: 'africa', position: [5.1, 1.2, 1.5], iframeSrc: "https://rss.app/embed/v1/list/hKdSIKMe0o5AmG18" },
  { id: 2, region: 'europe', position: [5.1, 0.7, 1.8], iframeSrc: "https://rss.app/embed/v1/list/sum7m4TJWVJk8HMN" },
  // Add other markers here...
  { id: 3, region: 'america', position: [5.1, 0.9, 0], iframeSrc: "https://rss.app/embed/v1/list/chAYVOo3llbQzNLo" },
  { id: 4, region: 'south america', position: [5.1, 1.6, 0.4], iframeSrc: "https://rss.app/embed/v1/list/DP9kzxo2dohbbgST" },
  { id: 5, region: 'middle east', position: [5.1, 1, 2.3],iframeSrc: "https://rss.app/embed/v1/list/JCYAnBzooyfhbDvO" },
  { id: 6, region: 'asia', position: [5.1, 0.9, 3], iframeSrc: "https://rss.app/embed/v1/list/pUeauCbzsXuVe3eC" },
  { id: 7, region: 'japan', position: [5.1, 0.9, 4], iframeSrc: "https://rss.app/embed/v1/list/d6hKxeycgIlya2NK" },
  { id: 8, region: 'carribbean', position: [5.1, 1.2, 0.2], iframeSrc: "https://rss.app/embed/v1/list/qvlJz8EBa0yKiH2i" },
  { id: 9, region: 'uk', position: [5.1, 0.6, 1.45], iframeSrc: "https://rss.app/embed/v1/list/VQIhB1FM0tC17q5Y" },
];
/*const genericMarkers = [
  { id: 1, position: [5.1, 1.2, 1.5], region: 'africa' },
  { id: 2, position: [5.1, 0.7, 1.8], region: 'europe' },
  { id: 3, position: [5.1, 0.9, 0], region: 'america' },
  { id: 4, position: [5.1, 1.6, 0.4], region: 'south america' },
  { id: 5, position: [5.1, 1, 2.3], region: 'middle east' },
  { id: 6, position: [5.1, 0.9, 3], region: 'asia' },
  { id: 7, position: [5.1, 0.9, 4], region: 'japan' },
  { id: 8, position: [5.1, 1.2, 0.2], region: 'carribbean' },
  { id: 9, position: [5.1, 0.6, 1.45], region: 'uk' },
];*/
	  // Convert latitude and longitude to 3D vector coordinates
/*function latLonToVector3(lat, lon, radius) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);
  const x = -(radius * Math.sin(phi) * Math.cos(theta));
  const y = radius * Math.cos(phi);
  const z = radius * Math.sin(phi) * Math.sin(theta);
  return { x, y, z };
}*/
function latLngToVector3(lat, lng, radius) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lng + 180) * (Math.PI / 180);

  const x = -(radius * Math.sin(phi) * Math.cos(theta));
  const y = radius * Math.cos(phi);
  const z = radius * Math.sin(phi) * Math.sin(theta);

  return new THREE.Vector3(x, y, z);
}


globe2 = new THREE.Mesh(geometry, earthMaterial);
// Initialize the globe and markers

  renderer.setSize(window.innerWidth, window.innerHeight);
  document.getElementById('globeContainer').appendChild(renderer.domElement);

  //globe2 = new THREE.Mesh(geometry, material2);
  scene.add(globe2);
  createEarthGlow();
  createEarthAperture();
	 const dummy = new THREE.Object3D();
	  /*const markerGeometry = new THREE.PlaneGeometry(1.1, 1.1); // Adjust size as needed
    const markerMaterial = new THREE.MeshBasicMaterial({
    color: daymarkerMaterial,
    onBeforeCompile: (shader) => {
      shader.uniforms.time = globalUniforms.time;
      shader.vertexShader = `
      	attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
        	vPhase = phase; // de-synch of ripples
        `
      );
      shader.fragmentShader = `
      	uniform float time;
        varying float vPhase;
      	${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });
  markerMaterial.defines = { USE_UV: '' };
	  const markers = new THREE.InstancedMesh(markerGeometry, markerMaterial, markersData.length);*/
    // Creating Markers
    const markerGeometry = new THREE.PlaneGeometry(1, 1);
    const markerMaterial = new THREE.MeshBasicMaterial({
    color: daymarkerMaterial,
    onBeforeCompile: (shader) => {
      shader.uniforms.time = globalUniforms.time;
      shader.vertexShader = `
      	attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
        	vPhase = phase; // de-synch of ripples
        `
      );
      shader.fragmentShader = `
      	uniform float time;
        varying float vPhase;
      	${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });
    const markers = new THREE.InstancedMesh(markerGeometry, markerMaterial, markersData.length);
// Function to load generic markers
function loadGenericMarkers(markersData) {
  // Check if the scene, marker data, and necessary variables are available
  if (!scene || !markersData || markersData.length === 0) {
    console.warn('Scene or markers data not available');
    return;
  }
  console.log('Loading generic markers...');
// Marker Geometry and Material
// Adjust marker size dynamically based on zoom level

  // Create the marker geometry and material
  //const markerGeometry = new THREE.PlaneGeometry(1.1, 1.1);
//const markerGeometry = new THREE.PlaneGeometry(1.1, 1.1); // Adjust size as needed
/*const markerMaterial = new THREE.MeshBasicMaterial({
    color: daymarkerMaterial,
    onBeforeCompile: (shader) => {
      shader.uniforms.time = globalUniforms.time;
      shader.vertexShader = `
      	attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
        	vPhase = phase; // de-synch of ripples
        `
      );
      shader.fragmentShader = `
      	uniform float time;
        varying float vPhase;
      	${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });*/
  markerMaterial.defines = { USE_UV: '' };
  console.log('Creating generic markers...');
  // Create an object to keep track of generic markers for each region
  window.genericMarkers = window.genericMarkers || {};

if (window.innerWidth <= 768) {
  markerGeometry.scale(1.25, 1.25, 1.25); // Scale for mobile
}

// Creating Markers
const markers = new THREE.InstancedMesh(markerGeometry, markerMaterial, markersData.length);

const dummy = new THREE.Object3D();
markersData.forEach((data, index) => {
  const [radius, phi, theta] = data.position; // Spherical coordinates (radius, phi, theta)

  // Use setFromSphericalCoords for spherical positioning on the globe
  dummy.position.setFromSphericalCoords(radius, phi, theta);
  dummy.lookAt(dummy.position.clone().setLength(radius + 1)); // Ensure marker faces outward
  dummy.updateMatrix();
  markers.setMatrixAt(index, dummy.matrix);
// Log marker data
console.log(`Marker ${index}: radius=${radius}, phi=${phi}, theta=${theta}`);

  data.worldPosition = dummy.position.clone(); // Store position for interaction (optional)
});
// Log region and saving marker
const region = markersData[0]?.region; // Assuming markersData has region info
  if (region) {
    console.log(`Saving generic markers for region: ${region}`);
    window.genericMarkers[region] = markers;
  } else {
    console.warn('Region data not found in markersData');
  }
// Save the marker to the genericMarkers object based on region
genericMarkers[markersData.region] = markers;
// Add the markers to the scene
scene.add(markers);
}

  
  loadGenericMarkers(markersData);
// Labels, Raycasting, and Interactions (leave as is from your original logic)
// Assuming each marker has a reference in the HTML list and vice versa
function highlightMarker(markerId) {
    const marker = markers.find(m => m.id === markerId);  // Find the marker by ID
    if (marker) {
        marker.material.color.set('green');  // Highlight the marker in green
    }
}

document.querySelectorAll('.listing').forEach(listing => {
    listing.addEventListener('mouseover', () => {
        const markerId = listing.getAttribute('data-marker-id');  // Ensure the listings have a marker ID
        highlightMarker(markerId);
    });

    listing.addEventListener('mouseout', () => {
        const markerId = listing.getAttribute('data-marker-id');
        unhighlightMarker(markerId);  // Reset the marker's color
    });
});

function unhighlightMarker(markerId) {
    const marker = markers.find(m => m.id === markerId);
    if (marker) {
        marker.material.color.set('original_color');  // Reset to original color
    }
}



/*// Load detailed markers for a specific region
function loadDetailedMarkers(regionCoordinates) {
  clearExistingMarkers();

  const detailedMarkers = getDetailedMarkersForRegion(regionCoordinates);
  detailedMarkers.forEach(marker => {
    const { x, y, z } = latLonToVector3(marker.position[0], marker.position[1], 5.1);  // Adjust radius as needed
    // Marker Geometry and Material
const markerGeometry = new THREE.PlaneGeometry(0.025, 0.025);  // Use a smaller size, adjust as needed

// Optionally scale markers for mobile
if (window.innerWidth <= 768) {
  markerGeometry.scale(0.5, 0.5, 0.5);  // Smaller for mobile
}


    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });

    const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
    markerMesh.position.set(x, y, z);
    markerMesh.name = `marker-${marker.id}`;  // Set a unique name

    globe2.add(markerMesh);
  });
*/
	  // Load detailed markers for a specific region (use regular Mesh for dynamic marker count)
// Load detailed markers for a specific region (use regular Mesh for dynamic marker count)
	   // Function to clear existing markers
function clearExistingMarkers() {
  const markers = scene.children.filter(obj => obj.name && obj.name.startsWith('marker-'));

  markers.forEach(marker => {
    // Dispose of the geometry and material to free up memory
    if (marker.geometry) marker.geometry.dispose();
    if (marker.material) {
      // If the material is an array (multi-material), dispose each
      if (Array.isArray(marker.material)) {
        marker.material.forEach(mat => mat.dispose());
      } else {
        marker.material.dispose();
      }
    }
    scene.remove(marker);  // Remove the marker from the scene
  });
}
async function loadDetailedMarkers(regionCoordinates) {
  clearExistingMarkers();  // Clear previously added markers

  // Fetch detailed markers dynamically for the region
  const detailedMarkers = await getDetailedMarkersForRegion(regionCoordinates); 

  // Iterate through the fetched markers and add them to the scene
  detailedMarkers.forEach((marker, index) => {
    const { lat, lng } = marker;  // Use latitude and longitude
    const { x, y, z } = latLngToVector3(lat, lng, earthRadius); // Convert to 3D coordinates

    // Create individual marker geometry and material
    const markerGeometry = new THREE.PlaneGeometry(0.7, 0.7);  // Use smaller size for detailed markers
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xff385c, side: THREE.DoubleSide });

    // Optionally scale markers for mobile
    if (window.innerWidth <= 768) {
      markerGeometry.scale(1.25, 1.25, 1.25);  // Smaller for mobile
    }

    const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
    markerMesh.position.set(x, y, z);
    markerMesh.name = `marker-${marker.id}`;  // Set a unique name for each marker

    // Add the marker to the scene (on the globe)
    scene.add(markerMesh);  
  });
}

// Example: Get detailed markers for a region
// Get detailed markers for a region (can be dynamic or hardcoded)
// Fetch detailed markers dynamically from an API or backend service
async function getDetailedMarkersForRegion(region) {
  try {
    // Make an API request to fetch the markers data for the specific region
    const response = await fetch(`http://bnb-navigator.com/get-markers?region=${region}&category=${category}`, {
  method: 'GET',
  credentials: 'include',  // If you need cookies or credentials
}).then(response => response.json())
  .then(markerLatLngs => {
    // Assume 'map' is your initialized Google Map or Mapbox map object

    // Loop through the marker data and add them to the map
    markerLatLngs.forEach(marker => {
      new Marker({
        position: { lat: marker.lat, lng: marker.lng },  // Use the lat/lng coordinates
        map: map,
        title: 'Airbnb Marker'
      });
    });
  })
  .catch(err => {
    console.error('Error fetching markers:', err);
  });
    // Parse the JSON response to get the markers data
    const markersData = await response.json(); 
console.log(response.json());
    return markersData; // Assuming the response contains an array of markers
  } catch (error) {
    console.error('Error fetching detailed markers for region:', error);
    return []; // Return an empty array if there's an error
  }
}



// Pan globe to a region
let currentRegion = null; // Keep track of the current region

// Function to hide a marker
function hideMarker(marker) {
  marker.visible = false;
}

// Function to show a marker
function showMarker(marker) {
  marker.visible = true;
}
// Pan globe to a region and handle marker visibility
function panGlobeToRegion(regionCoordinates, region) {
  if (camera && controls) {
    console.log(`Panning to region: ${region}`);  // Log selected region
    const { x, y, z } = latLngToVector3(regionCoordinates.lat, regionCoordinates.lng, 5.1);
    const targetPosition = new THREE.Vector3(x, y, z);

    new TWEEN.Tween(camera.position)
      .to(targetPosition, 2000)  // Smooth pan over 2 seconds
      .easing(TWEEN.Easing.Cubic.InOut)
      .onUpdate(() => controls.update())
      .start();
// Log camera movement
console.log(`Camera moving to: x=${x}, y=${y}, z=${z}`);
    // Hide the marker of the selected region after panning
    new TWEEN.Tween()
      .to({}, 2000)  // Add a delay equal to the camera pan
      .onComplete(() => {
        console.log(`Fetching and displaying detailed markers for region: ${region}`);
        // Fetch and display detailed markers for the selected region
        fetchMarkers(region);

        // Hide the current region's marker
        if (genericMarkers[region]) {
          console.log(`Hiding generic marker for region: ${region}`);
          hideMarker(genericMarkers[region]);
        } else {
          console.warn(`No generic marker found for region: ${region}`);
        }

        // If another region was previously selected, show its marker again
        if (currentRegion && currentRegion !== region && genericMarkers[currentRegion]) {
          console.log(`Showing generic marker for previously selected region: ${currentRegion}`);
          showMarker(genericMarkers[currentRegion]);
        }

        currentRegion = region; // Update the currently selected region
      })
      .start();
  } else {
    console.error('Camera or controls are not defined');
  }
}
	  // Function to pan the globe and load markers based on a location search
function searchForLocation(locationName) {
  const normalizedLocation = normalizeLocation2(locationName);  // Normalize input (e.g., lowercase)

  // Check if the location exists in the regions database
  const regionCoordinates = regions[normalizedLocation];
  
  if (regionCoordinates) {
    panGlobeToRegion(regionCoordinates);  // Pan the globe to the searched location
  } else {
    console.log('Location not found.');
  }
}
	  // Function to normalize the input location name
function normalizeLocation2(input) {
  return input.toLowerCase().trim();
}

// Get region coordinates based on region name
function getRegionCoordinates(region) {
  const regions = {
    "africa": { lat: 10, lng: 20 },
    "europe": { lat: 50, lng: 10 },
    "america": { lat: 40, lng: -100 },
    'south america': { lat: -10, lng: -55 },
    "carribbean": { lat: 20, lng: -75 },
    "asia": { lat: 30, lng: 100 },
    "world": { lat: 0, lng: 0 },
    "new york": { lat: 40.7128, lng: -74.0060 },
    "los angeles": { lat: 34.0522, lng: -118.2437 },
    "chicago": { lat: 41.8781, lng: -87.6298 },
    "miami": { lat: 25.7617, lng: -80.1918 },
    "san francisco": { lat: 37.7749, lng: -122.4194 },
    "washington dc": { lat: 38.9072, lng: -77.0369 },
    "london": { lat: 51.5074, lng: -0.1278 },
    "paris": { lat: 48.8566, lng: 2.3522 },
    "berlin": { lat: 52.5200, lng: 13.4050 },
    "rome": { lat: 41.9028, lng: 12.4964 },
    "madrid": { lat: 40.4168, lng: -3.7038 },
    "barcelona": { lat: 41.3851, lng: 2.1734 },
    "moscow": { lat: 55.7558, lng: 37.6173 },
    "tokyo": { lat: 35.6895, lng: 139.6917 },
    "beijing": { lat: 39.9042, lng: 116.4074 },
    "shanghai": { lat: 31.2304, lng: 121.4737 },
    "sydney": { lat: -33.8688, lng: 151.2093 },
    "melbourne": { lat: -37.8136, lng: 144.9631 },
    "rio de janeiro": { lat: -22.9068, lng: -43.1729 },
    "são paulo": { lat: -23.5505, lng: -46.6333 },
    "mexico city": { lat: 19.4326, lng: -99.1332 },
    "toronto": { lat: 43.651070, lng: -79.347015 },
    "vancouver": { lat: 49.2827, lng: -123.1207 },
    "montreal": { lat: 45.5017, lng: -73.5673 },
    "buenos aires": { lat: -34.6037, lng: -58.3816 },
    "cape town": { lat: -33.9249, lng: 18.4241 },
    "johannesburg": { lat: -26.2041, lng: 28.0473 },
    "cairo": { lat: 30.0444, lng: 31.2357 },
    "dubai": { lat: 25.2048, lng: 55.2708 },
    "istanbul": { lat: 41.0082, lng: 28.9784 },
    "delhi": { lat: 28.6139, lng: 77.2090 },
    "mumbai": { lat: 19.0760, lng: 72.8777 },
    "hong kong": { lat: 22.3193, lng: 114.1694 },
    "bangkok": { lat: 13.7563, lng: 100.5018 },
    "singapore": { lat: 1.3521, lng: 103.8198 },
    "kuala lumpur": { lat: 3.1390, lng: 101.6869 },
    "jakarta": { lat: -6.2088, lng: 106.8456 },
    "seoul": { lat: 37.5665, lng: 126.9780 },
    "lagos": { lat: 6.5244, lng: 3.3792 },
    "casablanca": { lat: 33.5731, lng: -7.5898 },
    "nairobi": { lat: -1.286389, lng: 36.817223 },
    "lima": { lat: -12.0464, lng: -77.0428 },
    "santiago": { lat: -33.4489, lng: -70.6693 },
    "athens": { lat: 37.9838, lng: 23.7275 },
    "lisbon": { lat: 38.7223, lng: -9.1393 },
    "vienna": { lat: 48.2082, lng: 16.3738 },
    "stockholm": { lat: 59.3293, lng: 18.0686 },
    "oslo": { lat: 59.9139, lng: 10.7522 },
    "helsinki": { lat: 60.1695, lng: 24.9354 },
    "warsaw": { lat: 52.2297, lng: 21.0122 },
    "zurich": { lat: 47.3769, lng: 8.5417 },
    "brussels": { lat: 50.8503, lng: 4.3517 },
    "amsterdam": { lat: 52.3676, lng: 4.9041 },
    "dublin": { lat: 53.3498, lng: -6.2603 },
    "copenhagen": { lat: 55.6761, lng: 12.5683 },
    "budapest": { lat: 47.4979, lng: 19.0402 },
    "prague": { lat: 50.0755, lng: 14.4378 },
    "doha": { lat: 25.276987, lng: 51.521067 },
    "jamaica": { lat: 18.1096, lng: -77.2975 } // Added Jamaica
  };
  return regions[region] || { lat: 0, lon: 0 };  // Default to world coordinates
}
	  
// Animation loop
//function animate() {
  //requestAnimationFrame(animate);
  //controls.update();
  //renderer.render(scene, camera);
//}

// Perform search and pan the globe
/*function performSearch(searchUrl, regionCoordinates) {

	// Ensure iframe exists before referencing
const iframe = document.getElementById('airbnbIframe');
if (iframe) {
  iframe.src = searchUrl;
} else {
  console.error('Iframe not found.');
}
	
  document.getElementById('container').classList.add('split-screen');
	
  panGlobeToRegion(regionCoordinates);
}*/

/*// Trigger search and globe pan when search button is clicked
document.getElementById('searchBtn').addEventListener('click', function () {
  const where = document.getElementById('where').value;
  const checkin = document.getElementById('checkin').value;
  const checkout = document.getElementById('checkout').value;
  const guests = document.getElementById('guests').value;
  const priceMin = document.getElementById('price_min').value;
  const priceMax = document.getElementById('price_max').value;

  if (!where || !checkin || !checkout || !guests) {
    alert('Please fill out all required fields.');
    return;
  }

  const searchUrl = `https://www.airbnb.com/s/${where}/homes?checkin=${checkin}&checkout=${checkout}&guests=${guests}&price_min=${priceMin}&price_max=${priceMax}`;
  const regionCoordinates = { lat: 50, lon: 10 };  // Example coordinates
  performSearch(searchUrl, regionCoordinates);
});*/
	/*  // When the user clicks search, generate the search URL and fetch the RSS feed
        document.getElementById('searchBtn').addEventListener('click', async function () {
            const location = document.getElementById('where').value;
            const checkin = document.getElementById('checkin').value;
            const checkout = document.getElementById('checkout').value;
            const guests = document.getElementById('guests').value;
            const priceMin = document.getElementById('price-min').value;
            const priceMax = document.getElementById('price-max').value;

            if (!location || !checkin || !checkout || !guests) {
                alert('Please fill out all required fields.');
                return;
            }

            // Generate the search URL dynamically
            const searchUrl = `https://www.airbnb.com/s/${location}/homes?checkin=${checkin}&checkout=${checkout}&guests=${guests}&price_min=${priceMin}&price_max=${priceMax}`;

            try {
                // Make a request to the Node.js server to get the RSS feed URL
                const response = await fetch(`https://airbnb-assistant-7e89835c55e1.herokuapp.com/get-rss?searchUrl=${encodeURIComponent(searchUrl)}`);
                const data = await response.json();

                if (data.placeId) {
			// Step 3: Generate the final RSS feed URL with the retrieved place_id
            const finalSearchUrl = `https://www.airbnb.com/s/${location}/homes?checkin=${checkin}&checkout=${checkout}&guests=${guests}&price_min=${priceMin}&price_max=${priceMax}&place_id=${data.placeId}`;
            const rssResponse = await fetch(`https://airbnb-assistant-7e89835c55e1.herokuapp.com/get-rss?searchUrl=${encodeURIComponent(finalSearchUrl)}`);
	       const rssData = await rssResponse.json();
			if (rssData.rssUrl) {
                    // Create an iframe and set its src to the RSS feed URL
                    const iframe = document.createElement('iframe');
                    iframe.src = data.rssUrl;
                    document.getElementById('left-container').innerHTML = '';  // Clear any previous content
                    document.getElementById('left-container').appendChild(iframe);
			} else {
                console.error('Failed to load RSS feed');
            }

		} else {
                    console.error('Failed to load RSS feed');
                }
            } catch (error) {
                console.error('Error fetching RSS feed:', error);
            }
        });
	  // Function to generate the dynamic RSS URL based on user input
function generateRssUrl(searchUrl) {
  // Extract parameters from the user input (e.g., searchUrl)
  const urlParams = new URLSearchParams(searchUrl);

  const checkin = urlParams.get('checkin') || '2024-09-25';
  const checkout = urlParams.get('checkout') || '2024-09-26';
  const adults = urlParams.get('adults') || '2';
  const placeId = urlParams.get('place_id') || 'ChIJU1NoiDs6BIQREZgJa760ZO0';  // Default place_id for Mexico
  
  // Replace the parameters in the RSS URL template
  const rssUrlTemplate = 'https://rss.app/new-rss-feed/rss-builder?cssGeneralTitle=div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20main%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20a%3Anth-child(1)&cssContainer=div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20main%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div&jsTimeout=auto&url=https%3A%2F%2Fwww.airbnb.com%2Fs%2FMexico%2Fhomes%3Ftab_id%3Dhome_tab%26refinement_paths%255B%255D%3D%252Fhomes%26adults%3D${adults}%26checkin%3D${checkin}%26checkout%3D${checkout}%26place_id%3D${placeId}';

  return rssUrlTemplate;
}

// Example usage:
const searchUrl = `https://www.airbnb.com/s/${location}/homes?checkin=${checkin}&checkout=${checkout}&guests=${guests}&price_min=${priceMin}&price_max=${priceMax}`;
const dynamicRssUrl = generateRssUrl(searchUrl);
console.log(dynamicRssUrl);  // Logs the updated RSS URL
*/
	  // When the user clicks search, generate the search URL and fetch the RSS feed
/*document.getElementById('searchBtn').addEventListener('click', async function () {
    const location = document.getElementById('where').value;
    const checkin = document.getElementById('checkin').value;
    const checkout = document.getElementById('checkout').value;
    const guests = document.getElementById('guests').value;
    const priceMin = document.getElementById('price_min').value;
    const priceMax = document.getElementById('price_max').value;

    // Ensure all required fields are filled out
    if (!location || !checkin || !checkout || !guests) {
        alert('Please fill out all required fields.');
        return;
    }

    // Generate the initial Airbnb search URL
    const searchUrl = `https://www.airbnb.com/s/${location}/homes?checkin=${checkin}&checkout=${checkout}&guests=${guests}&price_min=${priceMin}&price_max=${priceMax}`;

    try {
        // Fetch the placeId from the backend (which extracts it from Airbnb's page)
        const response = await fetch(`https://airbnb-assistant-7e89835c55e1.herokuapp.com/get-place-id?searchUrl=${encodeURIComponent(searchUrl)}`);
        const data = await response.json();

        if (data.placeId) {
            // Generate the final Airbnb search URL with the retrieved placeId
            const finalSearchUrl = `https://www.airbnb.com/s/${location}/homes?checkin=${checkin}&checkout=${checkout}&guests=${guests}&price_min=${priceMin}&price_max=${priceMax}&place_id=${data.placeId}`;
            
            // Fetch the RSS feed URL using the final search URL
            const rssResponse = await fetch(`https://airbnb-assistant-7e89835c55e1.herokuapp.com/get-rss?searchUrl=${encodeURIComponent(finalSearchUrl)}`);
            const rssData = await rssResponse.json();

            if (rssData.rssUrl) {
                // Create an iframe and set its src to the RSS feed URL
                const iframe = document.createElement('iframe');
                iframe.src = rssData.rssUrl; // Set the correct RSS feed URL here
                iframe.width = '100%';
                iframe.height = '500px';  // Adjust as necessary
                document.getElementById('left-container').innerHTML = '';  // Clear previous content
                document.getElementById('left-container').appendChild(iframe);
            } else {
                console.error('Failed to load RSS feed');
            }
        } else {
            console.error('Failed to retrieve place ID');
        }
    } catch (error) {
        console.error('Error fetching RSS feed:', error);
    }
});

// Function to generate the dynamic RSS URL based on user input
function generateRssUrl(searchUrl) {
    // Extract parameters from the user input (e.g., searchUrl)
    const urlParams = new URLSearchParams(searchUrl);

    const checkin = urlParams.get('checkin') || '2024-09-25';
    const checkout = urlParams.get('checkout') || '2024-09-26';
    const adults = urlParams.get('adults') || '2';
    const placeId = urlParams.get('place_id') || 'ChIJU1NoiDs6BIQREZgJa760ZO0';  // Default place_id for Mexico
    
    // Replace the parameters in the RSS URL template
    const rssUrlTemplate = `https://rss.app/new-rss-feed/rss-builder?cssGeneralTitle=div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20main%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20a%3Anth-child(1)&cssContainer=div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20main%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div%20%3E%20div&jsTimeout=auto&url=${encodeURIComponent(searchUrl)}`;
    return rssUrlTemplate;
}*/
// When the user clicks search, generate the search URL and fetch the RSS feed
// When the user clicks search, generate the search URL and fetch Airbnb posts
// Function to update the spinner text
function updateSpinnerText(message) {
    const spinnerText = document.querySelector('.spinner-text');
    if (spinnerText) {
        spinnerText.innerText = message;
    }
}

document.getElementById('searchBtn').addEventListener('click', async function () {
    const location = document.getElementById('where').value;
    const checkin = document.getElementById('checkin').value;
    const checkout = document.getElementById('checkout').value;
    const guests = document.getElementById('adults').value;
    const priceMin = document.getElementById('price_min').value;
    const priceMax = document.getElementById('price_max').value;
	
    /*const inputs = document.querySelectorAll('#header input');
    inputs.forEach(input => {
        input.style.color = 'darkgrey';  // Change placeholder text to dark grey
    });*/
    //document.getElementById('header').style.backgroundColor = 'white';  // Change header background to white
	
    // Show the close button
    document.getElementById('closeBtn').style.display = 'block';
	
    // Ensure all required fields are filled out
    if (!location || !checkin || !checkout || !guests) {
        alert('Please fill out all required fields.');
        return;
    }
// JavaScript to close the left-container and show the Three.js canvas
// Function to handle the close button click
document.getElementById('closeBtn').addEventListener('click', function () {
    // Hide the close button and the left container
    document.getElementById('closeBtn').style.display = 'none';
    document.getElementById('overlayContainer').style.display = 'none';
});


    // Show spinner and transition to split screen mode
    /*const leftContainer = document.getElementById('left-container');*/
    const globeContainer = document.getElementById('globeContainer');
    const overlay = document.getElementById('overlayContainer');
    // Check if the overlayContainer exists
    if (!overlay) {
        console.error("Overlay container not found!");
        return;
    }
    // Log to confirm the visibility change
    console.log("Displaying overlay...");

    // Use requestAnimationFrame to force a repaint
    /*requestAnimationFrame(() => {
        overlay.style.display = 'grid';
        overlay.classList.add('show');
    });*/
    overlay.style.display = 'grid';
    overlay.classList.add('show');
    
        overlay.innerHTML = `
            <div class="spinner-container">
                <div class="spinner"></div>
                <p class="spinner-text">Starting the process...</p>
            </div>
        `;
        function hideSpinnerContainer() {
    const spinnerContainer = document.querySelector('.spinner-container');
    if (spinnerContainer) {
        spinnerContainer.style.display = 'none';  // Hide the spinner container
    }
}

  
    // Show the spinner inside the left container
    /*leftContainer.innerHTML = `
        <div class="spinner-container">
            <div class="spinner"></div>
            <p class="spinner-text">Starting the process...</p>
        </div>
    `;
    leftContainer.style.display = 'block'; // Ensure the left container is visible
    

    // Shrink the globe-container to take only half the screen
    globeContainer.classList.add('split');
    leftContainer.classList.add('show'); // Show the left container
	// Switch to split-screen layout
    leftContainer.style.width = '50%';
    globeContainer.style.width = '50%';*/

    // Call the resize function for Three.js
    //resizeThreeJS(); // Ensure Three.js canvas is resized properly

	// Ensure Three.js globe resizes after the DOM update is complete
    //setTimeout(resizeThreeJS, 500); // Delay to ensure layout transition has completed

	// Function to resize the Three.js globe
    /*function resizeThreeJS() {
        if (window.renderer && window.camera) {
            const newWidth = globeContainer.clientWidth;
            const newHeight = globeContainer.clientHeight;
            window.renderer.setSize(newWidth, newHeight);
            window.camera.aspect = newWidth / newHeight;
            window.camera.updateProjectionMatrix();
        }
    }*/

    // Update the spinner text to indicate visiting Airbnb
    updateSpinnerText("Visiting Airbnb site...");

    // Generate the Airbnb search URL
    // Base URL for Airbnb search
    // Construct the initial Airbnb URL (without map bounds)
  // Get today's date
const today = new Date();
const tomorrow = new Date();
tomorrow.setDate(today.getDate() + 1);
 // Get the first day of the current month
const monthlyStartDate = new Date(today.getFullYear(), today.getMonth(), 1);

// Get the end date three months from the current month
const monthlyEndDate = new Date(today.getFullYear(), today.getMonth() + 3, 0); // 0 gives the last day of the previous month
// Format the dates to YYYY-MM-DD
const monthlyStart = monthlyStartDate.toISOString().split('T')[0];  // First day of current month
const monthlyEnd = monthlyEndDate.toISOString().split('T')[0];  // Last day of the month 3 months from now
    let searchUrl = `https://www.airbnb.com/s/${location}/homes?tab_id=home_tab&refinement_paths%5B%5D=%2Fhomes&adults=2&flexible_trip_lengths%5B%5D=one_week&monthly_start_date=${monthlyStart}&monthly_length=3&monthly_end_date=${monthlyEnd}&price_filter_input_type=0&channel=EXPLORE&date_picker_type=calendar&checkin=${checkin}&checkout=${checkout}&adults=${guests}&source=structured_search_input_header&search_type=unknown&price_filter_num_nights=1&drawer_open=true`;

    // Only add price_min and price_max if they have values
    if (priceMin && priceMin.trim() !== "") {
        searchUrl += `&price_min=${priceMin}`;
    }
    if (priceMax && priceMax.trim() !== "") {
        searchUrl += `&price_max=${priceMax}`;
    }
    // Debug the search URL (you can remove this after confirming it works)
    console.log('Generated searchUrl:', searchUrl);

	// Disable globe interactions when the left container is scrolled
    /*overlay.addEventListener('mouseenter', () => {
        globeContainer.classList.add('disable-interaction');
    });

    overlay.addEventListener('mouseleave', () => {
        globeContainer.classList.remove('disable-interaction');
    });*/

    // Update spinner text to indicate fetching data
    updateSpinnerText("Retrieving posts from Airbnb...");

    // Fetch Airbnb posts and display them
    await fetchAirbnbPosts(searchUrl);
	console.log('Generated searchUrl:', searchUrl);
	console.log('Generated searchUrl:location', location);
	console.log('Generated searchUrl:checkin', checkin);
	console.log('Generated searchUrl:checkout', checkout);
	console.log('Generated searchUrl:guests', guests);
	console.log('Generated searchUrl:priceMin', priceMin);
	console.log('Generated searchUrl:priceMax', priceMax);
	console.log('Fetching data from:', `https://airbnb-assistant-7e89835c55e1.herokuapp.com/scrape-airbnb?searchUrl=${encodeURIComponent(searchUrl)}`);
  hideSpinnerContainer();

});

// Function to fetch Airbnb posts from your backend and display them on the webpage
async function fetchAirbnbPosts(searchUrl) {
    try {
        // Update spinner text to indicate scraping started
        updateSpinnerText("Retrieving posts from Airbnb...");

        const response = await fetch(`http://localhost:3000/scrape-airbnb?searchUrl=${encodeURIComponent(searchUrl)}`);
        const data = await response.json();
         // Ensure that 'posts2' is an array before mapping
         const posts2 = Array.isArray(data.posts2) ? data.posts2 : [];

        console.log('Fetched posts:', data);

        // Update spinner text to indicate posts fetched
        updateSpinnerText("Displaying fetched listings...");
// Call populateOverlay to display posts
populateOverlay(posts2);

        // Display the posts on the webpage
       /* const container = document.getElementById('left-container');
        container.style.display = 'block';
        container.innerHTML = posts2.map(post => `
            <div class="post">
      	      <img src="${post.image}" alt="${post.title}" />
      	      <h3>${post.title}</h3>
	      <p>${post.subtitle}</p>
	      <p>Price: ${post.listing_price_details}</p>
	      <p>Rating: ${post.rating_out_of_5_stars}</p>
	      <a href="${post.link}" target="_blank" class="view-link">View Listing</a>
	    </div>
        `).join('');*/
        function extractPriceInfo(priceDetails) {
    // Example: "109 €77 night €77 per night"
    const regex = /(\d+\s?[€$£])\s+night\s+(\d+\s?[€$£])/;
    const match = priceDetails.match(regex);

    if (match) {
        return {
            totalPrice: match[1],         // Total price (e.g., "109 €")
            pricePerNight: match[2]      // Price per night (e.g., "77 €")
        };
    } else {
        console.warn('Price details format not recognized:', priceDetails);
        return { totalPrice: 'N/A', pricePerNight: 'N/A' };
    }
}

        function populateOverlay(posts2) {
    const overlay = document.getElementById('overlayContainer');
    overlay.innerHTML = ''; // Clear previous posts

    posts2.forEach(post => {
        const postDiv = document.createElement('div');
        postDiv.classList.add('post');

        // Add image
        const img = document.createElement('img');
        img.src = post.image || ''; // Use default image if not provided
        img.alt = post.title || 'Airbnb Listing';

        // Add title
        const title = document.createElement('h3');
        title.textContent = post.title || 'No title available';

        // Add subtitle
        const subtitle = document.createElement('p');
        subtitle.textContent = post.subtitle || 'No subtitle available';

        // Extract and separate price details
        const priceDetails = post.listing_price_details || 'N/A';
        const priceInfo = extractPriceInfo(priceDetails);

        // Add total price
        const price = document.createElement('p');
        price.textContent = `Total Price: ${priceInfo.totalPrice || 'N/A'}`;

        // Add price per night
        const pricePerNight = document.createElement('p');
        pricePerNight.textContent = `Price per Night: ${priceInfo.pricePerNight || 'N/A'}`;

        // Add rating
        const rating = document.createElement('p');
        rating.textContent = `Rating: ${post.rating_out_of_5_stars || 'N/A'}`;

        // Add "View Listing" link
        const viewLink = document.createElement('a');
        viewLink.href = post.link || '#';
        viewLink.target = '_blank';
        viewLink.textContent = 'View Listing';
        viewLink.classList.add('view-link');

        // Append elements to the postDiv
        postDiv.appendChild(img);
        postDiv.appendChild(title);
        postDiv.appendChild(subtitle);
        postDiv.appendChild(price);
        postDiv.appendChild(pricePerNight);
        postDiv.appendChild(rating);
        postDiv.appendChild(viewLink);

        // Append the postDiv to the overlay
        overlay.appendChild(postDiv);
    });
}

      } catch (error) {
        console.error('Error fetching posts:', error);
        // Update spinner text to indicate an error occurred
        updateSpinnerText("Error fetching Airbnb listings. Please try again.");
    }
}
document.querySelectorAll('.post-grid').forEach((item, index) => {
    // Make sure `index` matches the corresponding marker
    item.addEventListener('mouseover', function() {
        if (markers[index]) {  // Check if the marker exists
            markers[index].material.color.set(0x00ff00);  // Highlight the marker in green
        }
    });
    
    item.addEventListener('mouseout', function() {
        if (markers[index]) {
            markers[index].material.color.set(0xffffff);  // Reset the color when mouse leaves (default color)
        }
    });

    item.addEventListener('click', function() {
        if (markers[index]) {
            markers[index].material.color.set(0xff385c);  // Set the marker color to red on click
        }
    });
});

	  // A lookup table for example (you can expand this)
// Lookup table with expanded locations, including Jamaica
/*const locations = {
    "new york": { lat: 40.7128, lng: -74.0060 },
    "los angeles": { lat: 34.0522, lng: -118.2437 },
    "chicago": { lat: 41.8781, lng: -87.6298 },
    "miami": { lat: 25.7617, lng: -80.1918 },
    "san francisco": { lat: 37.7749, lng: -122.4194 },
    "washington dc": { lat: 38.9072, lng: -77.0369 },
    "london": { lat: 51.5074, lng: -0.1278 },
    "paris": { lat: 48.8566, lng: 2.3522 },
    "berlin": { lat: 52.5200, lng: 13.4050 },
    "rome": { lat: 41.9028, lng: 12.4964 },
    "madrid": { lat: 40.4168, lng: -3.7038 },
    "barcelona": { lat: 41.3851, lng: 2.1734 },
    "moscow": { lat: 55.7558, lng: 37.6173 },
    "tokyo": { lat: 35.6895, lng: 139.6917 },
    "beijing": { lat: 39.9042, lng: 116.4074 },
    "shanghai": { lat: 31.2304, lng: 121.4737 },
    "sydney": { lat: -33.8688, lng: 151.2093 },
    "melbourne": { lat: -37.8136, lng: 144.9631 },
    "rio de janeiro": { lat: -22.9068, lng: -43.1729 },
    "são paulo": { lat: -23.5505, lng: -46.6333 },
    "mexico city": { lat: 19.4326, lng: -99.1332 },
    "toronto": { lat: 43.651070, lng: -79.347015 },
    "vancouver": { lat: 49.2827, lng: -123.1207 },
    "montreal": { lat: 45.5017, lng: -73.5673 },
    "buenos aires": { lat: -34.6037, lng: -58.3816 },
    "cape town": { lat: -33.9249, lng: 18.4241 },
    "johannesburg": { lat: -26.2041, lng: 28.0473 },
    "cairo": { lat: 30.0444, lng: 31.2357 },
    "dubai": { lat: 25.2048, lng: 55.2708 },
    "istanbul": { lat: 41.0082, lng: 28.9784 },
    "delhi": { lat: 28.6139, lng: 77.2090 },
    "mumbai": { lat: 19.0760, lng: 72.8777 },
    "hong kong": { lat: 22.3193, lng: 114.1694 },
    "bangkok": { lat: 13.7563, lng: 100.5018 },
    "singapore": { lat: 1.3521, lng: 103.8198 },
    "kuala lumpur": { lat: 3.1390, lng: 101.6869 },
    "jakarta": { lat: -6.2088, lng: 106.8456 },
    "seoul": { lat: 37.5665, lng: 126.9780 },
    "lagos": { lat: 6.5244, lng: 3.3792 },
    "casablanca": { lat: 33.5731, lng: -7.5898 },
    "nairobi": { lat: -1.286389, lng: 36.817223 },
    "lima": { lat: -12.0464, lng: -77.0428 },
    "santiago": { lat: -33.4489, lng: -70.6693 },
    "athens": { lat: 37.9838, lng: 23.7275 },
    "lisbon": { lat: 38.7223, lng: -9.1393 },
    "vienna": { lat: 48.2082, lng: 16.3738 },
    "stockholm": { lat: 59.3293, lng: 18.0686 },
    "oslo": { lat: 59.9139, lng: 10.7522 },
    "helsinki": { lat: 60.1695, lng: 24.9354 },
    "warsaw": { lat: 52.2297, lng: 21.0122 },
    "zurich": { lat: 47.3769, lng: 8.5417 },
    "brussels": { lat: 50.8503, lng: 4.3517 },
    "amsterdam": { lat: 52.3676, lng: 4.9041 },
    "dublin": { lat: 53.3498, lng: -6.2603 },
    "copenhagen": { lat: 55.6761, lng: 12.5683 },
    "budapest": { lat: 47.4979, lng: 19.0402 },
    "prague": { lat: 50.0755, lng: 14.4378 },
    "doha": { lat: 25.276987, lng: 51.521067 },
    "jamaica": { lat: 18.1096, lng: -77.2975 } // Added Jamaica
};*/

	  /*const locations = {
    "new york": { lat: 40.7128, lng: -74.0060, zoom: 2.5 },
    "los angeles": { lat: 34.0522, lng: -118.2437, zoom: 2.2 },
    "chicago": { lat: 41.8781, lng: -87.6298, zoom: 2.5 },
    "miami": { lat: 25.7617, lng: -80.1918, zoom: 2.7 },
    "san francisco": { lat: 37.7749, lng: -122.4194, zoom: 2.4 },
    "washington dc": { lat: 38.9072, lng: -77.0369, zoom: 2.5 },
    "london": { lat: 51.5074, lng: -0.1278, zoom: 2.8 },
    "paris": { lat: 48.8566, lng: 2.3522, zoom: 2.8 },
    "berlin": { lat: 52.5200, lng: 13.4050, zoom: 2.7 },
    "rome": { lat: 41.9028, lng: 12.4964, zoom: 2.9 },
    "madrid": { lat: 40.4168, lng: -3.7038, zoom: 2.7 },
    "barcelona": { lat: 41.3851, lng: 2.1734, zoom: 2.8 },
    "moscow": { lat: 55.7558, lng: 37.6173, zoom: 2.6 },
    "tokyo": { lat: 35.6895, lng: 139.6917, zoom: 2.9 },
    "beijing": { lat: 39.9042, lng: 116.4074, zoom: 2.8 },
    "shanghai": { lat: 31.2304, lng: 121.4737, zoom: 2.7 },
    "sydney": { lat: -33.8688, lng: 151.2093, zoom: 2.6 },
    "melbourne": { lat: -37.8136, lng: 144.9631, zoom: 2.7 },
    "rio de janeiro": { lat: -22.9068, lng: -43.1729, zoom: 2.8 },
    "são paulo": { lat: -23.5505, lng: -46.6333, zoom: 2.6 },
    "mexico city": { lat: 19.4326, lng: -99.1332, zoom: 2.7 },
    "toronto": { lat: 43.651070, lng: -79.347015, zoom: 2.5 },
    "vancouver": { lat: 49.2827, lng: -123.1207, zoom: 2.4 },
    "montreal": { lat: 45.5017, lng: -73.5673, zoom: 2.5 },
    "buenos aires": { lat: -34.6037, lng: -58.3816, zoom: 2.9 },
    "cape town": { lat: -33.9249, lng: 18.4241, zoom: 2.8 },
    "johannesburg": { lat: -26.2041, lng: 28.0473, zoom: 2.7 },
    "cairo": { lat: 30.0444, lng: 31.2357, zoom: 2.9 },
    "dubai": { lat: 25.2048, lng: 55.2708, zoom: 2.8 },
    "istanbul": { lat: 41.0082, lng: 28.9784, zoom: 2.7 },
    "delhi": { lat: 28.6139, lng: 77.2090, zoom: 2.8 },
    "mumbai": { lat: 19.0760, lng: 72.8777, zoom: 2.8 },
    "hong kong": { lat: 22.3193, lng: 114.1694, zoom: 2.9 },
    "bangkok": { lat: 13.7563, lng: 100.5018, zoom: 2.8 },
    "singapore": { lat: 1.3521, lng: 103.8198, zoom: 2.9 },
    "kuala lumpur": { lat: 3.1390, lng: 101.6869, zoom: 2.8 },
    "jakarta": { lat: -6.2088, lng: 106.8456, zoom: 2.7 },
    "seoul": { lat: 37.5665, lng: 126.9780, zoom: 2.8 },
    "lagos": { lat: 6.5244, lng: 3.3792, zoom: 2.6 },
    "casablanca": { lat: 33.5731, lng: -7.5898, zoom: 2.7 },
    "nairobi": { lat: -1.2864, lng: 36.8172, zoom: 2.6 },
    "lima": { lat: -12.0464, lng: -77.0428, zoom: 2.7 },
    "santiago": { lat: -33.4489, lng: -70.6693, zoom: 2.7 },
    "athens": { lat: 37.9838, lng: 23.7275, zoom: 2.8 },
    "lisbon": { lat: 38.7223, lng: -9.1393, zoom: 2.7 },
    "vienna": { lat: 48.2082, lng: 16.3738, zoom: 2.8 },
    "stockholm": { lat: 59.3293, lng: 18.0686, zoom: 2.7 },
    "oslo": { lat: 59.9139, lng: 10.7522, zoom: 2.7 },
    "helsinki": { lat: 60.1695, lng: 24.9354, zoom: 2.7 },
    "warsaw": { lat: 52.2297, lng: 21.0122, zoom: 2.8 },
    "zurich": { lat: 47.3769, lng: 8.5417, zoom: 2.8 },
    "brussels": { lat: 50.8503, lng: 4.3517, zoom: 2.8 },
    "amsterdam": { lat: 52.3676, lng: 4.9041, zoom: 2.8 },
    "dublin": { lat: 53.3498, lng: -6.2603, zoom: 2.8 },
    "copenhagen": { lat: 55.6761, lng: 12.5683, zoom: 2.7 },
    "budapest": { lat: 47.4979, lng: 19.0402, zoom: 2.8 },
    "prague": { lat: 50.0755, lng: 14.4378, zoom: 2.8 },
    "doha": { lat: 25.276987, lng: 51.521067, zoom: 2.7 },
    "jamaica": { lat: 18.1096, lng: -77.2975, zoom: 2.6 },
    "united states": { lat: 37.0902, lng: -95.7129, zoom: 2.4 },
    "canada": { lat: 56.1304, lng: -106.3468, zoom: 2.4 },
    "mexico": { lat: 23.6345, lng: -102.5528, zoom: 2.5 },
    "brazil": { lat: -14.2350, lng: -51.9253, zoom: 2.6 },
    "argentina": { lat: -38.4161, lng: -63.6167, zoom: 2.7 },
    "united kingdom": { lat: 55.3781, lng: -3.4360, zoom: 2.6 },
    "france": { lat: 46.6034, lng: 2.2137, zoom: 2.8 },
    "germany": { lat: 51.1657, lng: 10.4515, zoom: 2.8 },
    "italy": { lat: 41.8719, lng: 12.5674, zoom: 2.8 },
    "spain": { lat: 40.4637, lng: -3.7492, zoom: 2.7 },
    "portugal": { lat: 39.3999, lng: -8.2245, zoom: 2.7 },
    "russia": { lat: 61.5240, lng: 105.3188, zoom: 2.4 },
    "china": { lat: 35.8617, lng: 104.1954, zoom: 2.6 },
    "japan": { lat: 36.2048, lng: 138.2529, zoom: 2.7 },
    "india": { lat: 20.5937, lng: 78.9629, zoom: 2.7 },
    "australia": { lat: -25.2744, lng: 133.7751, zoom: 2.5 },
    "south africa": { lat: -30.5595, lng: 22.9375, zoom: 2.6 },
    "egypt": { lat: 26.8206, lng: 30.8025, zoom: 2.8 },
    "nigeria": { lat: 9.0820, lng: 8.6753, zoom: 2.7 },
    "kenya": { lat: -1.2921, lng: 36.8219, zoom: 2.7 },
    "south korea": { lat: 35.9078, lng: 127.7669, zoom: 2.8 },
    "indonesia": { lat: -0.7893, lng: 113.9213, zoom: 2.7 },
    "saudi arabia": { lat: 23.8859, lng: 45.0792, zoom: 2.7 },
    "iran": { lat: 32.4279, lng: 53.6880, zoom: 2.7 },
    "turkey": { lat: 38.9637, lng: 35.2433, zoom: 2.7 },
    "israel": { lat: 31.0461, lng: 34.8516, zoom: 2.8 },
    "greece": { lat: 39.0742, lng: 21.8243, zoom: 2.8 },
    "thailand": { lat: 15.8700, lng: 100.9925, zoom: 2.7 },
    "vietnam": { lat: 14.0583, lng: 108.2772, zoom: 2.7 },
    "new zealand": { lat: -40.9006, lng: 174.8860, zoom: 2.5 },
    "pakistan": { lat: 30.3753, lng: 69.3451, zoom: 2.7 },
    "afghanistan": { lat: 33.9391, lng: 67.7100, zoom: 2.6 },
    "colombia": { lat: 4.5709, lng: -74.2973, zoom: 2.7 },
    "venezuela": { lat: 6.4238, lng: -66.5897, zoom: 2.7 }
};*/
const locations = {
    "africa": { lat: 10, lng: 20, zoom: 1.4 },
    "europe": { lat: 50, lng: 10, zoom: 1.4 },
    "america": { lat: 40, lng: -100, zoom: 1.4 },
    'south america': { lat: -10, lng: -55, zoom: 1.4 },
    "carribbean": { lat: 20, lng: -75, zoom: 1.4 },
    "asia": { lat: 30, lng: 100, zoom: 1.4 },
    "world": { lat: 0, lng: 0, zoom: 1.4 },
    "new york": { lat: 40.7128, lng: -74.0060, zoom: 1.4 },
    "los angeles": { lat: 34.0522, lng: -118.2437, zoom: 1.4 },
    "chicago": { lat: 41.8781, lng: -87.6298, zoom: 1.4 },
    "miami": { lat: 25.7617, lng: -80.1918, zoom: 1.4 },
    "san francisco": { lat: 37.7749, lng: -122.4194, zoom: 1.4 },
    "washington dc": { lat: 38.9072, lng: -77.0369, zoom: 1.4 },
    "london": { lat: 51.5074, lng: -0.1278, zoom: 1.4 },
    "paris": { lat: 48.8566, lng: 2.3522, zoom: 1.4 },
    "berlin": { lat: 52.5200, lng: 13.4050, zoom: 1.4 },
    "rome": { lat: 41.9028, lng: 12.4964, zoom: 1.4 },
    "madrid": { lat: 40.4168, lng: -3.7038, zoom: 1.4 },
    "barcelona": { lat: 41.3851, lng: 2.1734, zoom: 1.4 },
    "moscow": { lat: 55.7558, lng: 37.6173, zoom: 1.4 },
    "tokyo": { lat: 35.6895, lng: 139.6917, zoom: 1.4 },
    "beijing": { lat: 39.9042, lng: 116.4074, zoom: 1.4 },
    "shanghai": { lat: 31.2304, lng: 121.4737, zoom: 1.4 },
    "sydney": { lat: -33.8688, lng: 151.2093, zoom: 1.4 },
    "melbourne": { lat: -37.8136, lng: 144.9631, zoom: 1.4 },
    "rio de janeiro": { lat: -22.9068, lng: -43.1729, zoom: 1.4 },
    "são paulo": { lat: -23.5505, lng: -46.6333, zoom: 1.4 },
    "mexico city": { lat: 19.4326, lng: -99.1332, zoom: 1.4 },
    "toronto": { lat: 43.651070, lng: -79.347015, zoom: 1.4 },
    "vancouver": { lat: 49.2827, lng: -123.1207, zoom: 1.4 },
    "montreal": { lat: 45.5017, lng: -73.5673, zoom: 1.4 },
    "buenos aires": { lat: -34.6037, lng: -58.3816, zoom: 1.4 },
    "cape town": { lat: -33.9249, lng: 18.4241, zoom: 1.4 },
    "johannesburg": { lat: -26.2041, lng: 28.0473, zoom: 1.4 },
    "cairo": { lat: 30.0444, lng: 31.2357, zoom: 1.4 },
    "dubai": { lat: 25.2048, lng: 55.2708, zoom: 1.4 },
    "istanbul": { lat: 41.0082, lng: 28.9784, zoom: 1.4 },
    "delhi": { lat: 28.6139, lng: 77.2090, zoom: 1.4 },
    "mumbai": { lat: 19.0760, lng: 72.8777, zoom: 1.4 },
    "hong kong": { lat: 22.3193, lng: 114.1694, zoom: 1.4 },
    "bangkok": { lat: 13.7563, lng: 100.5018, zoom: 1.4 },
    "singapore": { lat: 1.3521, lng: 103.8198, zoom: 1.4 },
    "kuala lumpur": { lat: 3.1390, lng: 101.6869, zoom: 1.4 },
    "jakarta": { lat: -6.2088, lng: 106.8456, zoom: 1.4 },
    "seoul": { lat: 37.5665, lng: 126.9780, zoom: 1.4 },
    "lagos": { lat: 6.5244, lng: 3.3792, zoom: 1.4 },
    "casablanca": { lat: 33.5731, lng: -7.5898, zoom: 1.4 },
    "nairobi": { lat: -1.2864, lng: 36.8172, zoom: 1.4 },
    "lima": { lat: -12.0464, lng: -77.0428, zoom: 1.4 },
    "santiago": { lat: -33.4489, lng: -70.6693, zoom: 1.4 },
    "athens": { lat: 37.9838, lng: 23.7275, zoom: 1.4 },
    "lisbon": { lat: 38.7223, lng: -9.1393, zoom: 1.4 },
    "vienna": { lat: 48.2082, lng: 16.3738, zoom: 1.4 },
    "stockholm": { lat: 59.3293, lng: 18.0686, zoom: 1.4 },
    "oslo": { lat: 59.9139, lng: 10.7522, zoom: 1.4 },
    "helsinki": { lat: 60.1695, lng: 24.9354, zoom: 1.4 },
    "warsaw": { lat: 52.2297, lng: 21.0122, zoom: 1.4 },
    "zurich": { lat: 47.3769, lng: 8.5417, zoom: 1.4 },
    "brussels": { lat: 50.8503, lng: 4.3517, zoom: 1.4 },
    "amsterdam": { lat: 52.3676, lng: 4.9041, zoom: 1.4 },
    "dublin": { lat: 53.3498, lng: -6.2603, zoom: 1.4 },
    "copenhagen": { lat: 55.6761, lng: 12.5683, zoom: 1.4 },
    "budapest": { lat: 47.4979, lng: 19.0402, zoom: 1.4 },
    "prague": { lat: 50.0755, lng: 14.4378, zoom: 1.4 },
    "doha": { lat: 25.276987, lng: 51.521067, zoom: 1.4 },
    "jamaica": { lat: 18.1096, lng: -77.2975, zoom: 1.4 },
    "united states": { lat: 37.0902, lng: -95.7129, zoom: 1.4 },
    "canada": { lat: 56.1304, lng: -106.3468, zoom: 1.4 },
    "mexico": { lat: 23.6345, lng: -102.5528, zoom: 1.4 },
    "brazil": { lat: -14.2350, lng: -51.9253, zoom: 1.4 },
    "argentina": { lat: -38.4161, lng: -63.6167, zoom: 1.4 },
    "united kingdom": { lat: 55.3781, lng: -3.4360, zoom: 1.4 },
    "france": { lat: 46.6034, lng: 2.2137, zoom: 1.4 },
    "germany": { lat: 51.1657, lng: 10.4515, zoom: 1.4 },
    "italy": { lat: 41.8719, lng: 12.5674, zoom: 1.4 },
    "spain": { lat: 40.4637, lng: -3.7492, zoom: 1.4 },
    "portugal": { lat: 39.3999, lng: -8.2245, zoom: 1.4 },
    "russia": { lat: 61.5240, lng: 105.3188, zoom: 1.4 },
    "china": { lat: 35.8617, lng: 104.1954, zoom: 1.4 },
    "japan": { lat: 36.2048, lng: 138.2529, zoom: 1.4 },
    "india": { lat: 20.5937, lng: 78.9629, zoom: 1.4 },
    "australia": { lat: -25.2744, lng: 133.7751, zoom: 1.4 },
    "south africa": { lat: -30.5595, lng: 22.9375, zoom: 1.4 },
    "egypt": { lat: 26.8206, lng: 30.8025, zoom: 1.4 },
    "nigeria": { lat: 9.0820, lng: 8.6753, zoom: 1.4 },
    "kenya": { lat: -1.2921, lng: 36.8219, zoom: 1.4 },
    "south korea": { lat: 35.9078, lng: 127.7669, zoom: 1.4 },
    "indonesia": { lat: -0.7893, lng: 113.9213, zoom: 1.4 },
    "saudi arabia": { lat: 23.8859, lng: 45.0792, zoom: 1.4 },
    "iran": { lat: 32.4279, lng: 53.6880, zoom: 1.4 },
    "turkey": { lat: 38.9637, lng: 35.2433, zoom: 1.4 },
    "israel": { lat: 31.0461, lng: 34.8516, zoom: 1.4 },
    "greece": { lat: 39.0742, lng: 21.8243, zoom: 1.4 },
    "thailand": { lat: 15.8700, lng: 100.9925, zoom: 1.4 },
    "vietnam": { lat: 14.0583, lng: 108.2772, zoom: 1.4 },
    "new zealand": { lat: -40.9006, lng: 174.8860, zoom: 1.4 },
    "pakistan": { lat: 30.3753, lng: 69.3451, zoom: 1.4 },
    "afghanistan": { lat: 33.9391, lng: 67.7100, zoom: 1.4 },
    "colombia": { lat: 4.5709, lng: -74.2973, zoom: 1.4 },
    "venezuela": { lat: 6.4238, lng: -66.5897, zoom: 1.4 }
};








// Function to normalize input and accept lower/upper case spelling
function normalizeLocation(input) {
    // Convert the input to lowercase and trim any whitespace
    return input.toLowerCase().trim();
}
function panToLocation(location) {
    const normalizedLocation = normalizeLocation(location);
    const coords = locations[normalizedLocation];
    
    if (coords) {
        // Convert latitude and longitude to Three.js coordinates
        const lat = coords.lat;
        const lng = coords.lng;
        const zoom = coords.zoom || 3.0; // Default zoom level if not provided

        // Calculate the target position in 3D space
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lng + 180) * (Math.PI / 180);
	    
        const radius = 5.1;  // Updated globe radius
        const targetX = radius * Math.sin(phi) * Math.cos(theta); // Adjust globe radius accordingly
        const targetY = radius * Math.cos(phi);
        const targetZ = radius * Math.sin(phi) * Math.sin(theta);

        // Use TWEEN for smooth animation
        new TWEEN.Tween(camera.position)
            .to({ x: targetX, y: targetY, z: targetZ }, 2000) // Smooth pan over 2 seconds
            .easing(TWEEN.Easing.Quadratic.InOut) // Apply easing for smoother effect
            .onUpdate(() => {
                camera.lookAt(0, 0, 0); // Keep the camera focused on the globe's center
            })
            .start();

        // Use another TWEEN for zooming effect
        new TWEEN.Tween(camera)
            .to({ zoom: zoom }, 2000) // Smooth zoom over 2 seconds
            .easing(TWEEN.Easing.Quadratic.InOut) // Apply easing for smoother effect
            .onUpdate(() => {
                camera.updateProjectionMatrix(); // Make sure to update the projection matrix after zoom changes
            })
            .start();

        // Make sure to call this to keep TWEEN animations running
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); // Update TWEEN animations
        }

        animate(); // Start the animation loop
    } else {
        console.log("Location not found in lookup table.");
    }
}
// Step 1: Function to create a 3D vector from latitude and longitude
// Convert Lat/Lng to 3D Vector

import { GLTFLoader } from 'https://unpkg.com/three@0.136.0/examples/jsm/loaders/GLTFLoader.js';

// Create the flight path curve
function createFlightPath(fromVec, toVec, altitude) {
  //const midPoint = fromVec.clone().lerp(toVec, 0.5);  // Midpoint for the curve
  const altitudeOffset = 0.01; // Offset to lift the line above the globe surface
    const controlPoints = []; // Points for the curve, from start to end
    // You can create a curve here, e.g., using a quadratic or cubic Bezier curve for smooth flight paths
   //midPoint.setLength(altitude);  // Adjust altitude for curve height
    //const midPoint = fromVec.clone().lerp(toVec, 0.5);
//midPoint.setLength(earthRadius + altitude); // Altitude adjusts the curve height above the globe
const midPoint = fromVec.clone().lerp(toVec, 0.5);

// Calculate a smoother altitude adjustment to keep the curve close to the globe's surface.
const midpointAltitude = earthRadius + altitude * 0.5; // Reduce altitude impact
midPoint.setLength(midpointAltitude); // Set midpoint altitude closer to the globe


  const curve = new THREE.QuadraticBezierCurve3(fromVec, midPoint, toVec);

  const pathGeometry = new THREE.TubeGeometry(curve, 20, 0.02, 8, false);
  const pathMaterial = new THREE.MeshBasicMaterial({ color: 0x46dff0 });
  const flightPath = new THREE.Mesh(pathGeometry, pathMaterial);

  scene.add(flightPath);
  return { flightPath, curve };  // Return both the path and the curve
}


// Step 6: Animate the plane along the curve
function animatePlane(plane, pathCurve, duration = 5000) {
    let progress = { t: 0 };

    function animateFlight() {
        new TWEEN.Tween(progress)
            .to({ t: 1 }, duration)  // Duration of the flight (in milliseconds)
            .onUpdate(() => {
                const point = pathCurve.getPointAt(progress.t);
                plane.position.set(point.x, point.y, point.z);

                const tangent = pathCurve.getTangentAt(progress.t).normalize();
                const normal = plane.position.clone().normalize();  // Globe is centered at (0,0,0)
                const up = normal.clone();

                plane.lookAt(plane.position.clone().add(tangent));
                plane.up.copy(up);  // Align the plane's "up" vector with the globe's surface
                plane.updateMatrixWorld();
            })
            .onComplete(() => {
                progress.t = 0;  // Reset to loop the animation
                animateFlight();  // Restart the flight animation
            })
            .start();
    }

    animateFlight();  // Start the initial animation
}


// When search button is clicked
document.getElementById('searchBtn').addEventListener('click', async () => {
    // Get selected "from" and "to" locations from the user
    const fromLocation = document.getElementById('from').value.toLowerCase();
    const toLocation = document.getElementById('where').value.toLowerCase();
    controls.autoRotate = true;

    // Validate locations
    if (!locations[fromLocation] || !locations[toLocation]) {
        console.error('Invalid locations selected.');
        return;
    }

    // Get lat/lng for the "from" and "to" locations
    const fromLatLng = locations[fromLocation];
    const toLatLng = locations[toLocation];

    // Convert lat/lng to 3D vectors (globe radius is passed)
    const fromVector = latLngToVector3(fromLatLng.lat, fromLatLng.lng, earthRadius);
    const toVector = latLngToVector3(toLatLng.lat, toLatLng.lng, earthRadius);

    // Create a flight path and animate the plane
    const { flightPath, curve } = createFlightPath(fromVector, toVector, earthRadius * 1.1);

    // Load and animate the plane
    const loader = new GLTFLoader();
    loader.load('js/cartoon_low_poly_private_jet/scene.gltf', function (gltf) {
        const plane = gltf.scene;
        scene.add(plane);
        plane.scale.set(0.1, 0.1, 0.1);

        // Update plane materials
        plane.traverse((child) => {
            if (child.isMesh) {
                const materialName = child.material.name;

                // Update specific materials
                if (materialName === 'body') child.material.color.set(0xffffff);
                if (materialName === 'orange') child.material.color.set(0xffffff);
                if (materialName === 'glass') child.material.color.set(0x000000);
                if (materialName === 'Jet__0') child.material.color.set(0xaaaaaa);
            }
        });

        // Animate plane along the flight path
        animatePlane(plane, curve);
    });

    // Pan to the "to" location
    const location = document.getElementById('where').value;
    panToLocation(location);
// Add light pillars and wave effects at "from" and "to" locations
addMarkupPoints(fromLatLng, toLatLng);
    console.log('markupPointGroup added to globe2:', addMarkupPoints);
    // Fetch and update markers based on the selected category
    const selectedCategory = document.getElementById('priceCategorySelect').value;
    fetchMarkers(location, selectedCategory);

    // Resize and update all markers
    // Resize and update all markers with animation
Object.keys(genericMarkers).forEach(region => {
    const markers = genericMarkers[region];
    if (markers) {
        const originalMarkerSize = 1; // Assume original size was 0.5
        const targetMarkerSize = 0.25; // Target size (smaller)

        for (let i = 0; i < markers.count; i++) {
            const instanceMatrix = new THREE.Matrix4();
            markers.getMatrixAt(i, instanceMatrix);

            // Create marker mesh with initial size
            const markerMesh = new THREE.Mesh(new THREE.PlaneGeometry(originalMarkerSize, originalMarkerSize), markerMaterial);
            markerMesh.applyMatrix4(instanceMatrix);
            scene.add(markerMesh); // Add marker to scene

            // Animation variables
            let currentSize = originalMarkerSize;

            // Function to animate the resizing of markers
            const animateResize = () => {
                currentSize = THREE.MathUtils.lerp(currentSize, targetMarkerSize, 0.1); // Smoothly interpolate size
                markerMesh.geometry.dispose(); // Dispose of old geometry
                markerMesh.geometry = new THREE.PlaneGeometry(currentSize, currentSize); // Update geometry

                if (Math.abs(currentSize - targetMarkerSize) > 0.01) {
                    requestAnimationFrame(animateResize); // Continue animation until target size is reached
                } else {
                    // Ensure final size is set
                    markerMesh.geometry.dispose();
                    markerMesh.geometry = new THREE.PlaneGeometry(targetMarkerSize, targetMarkerSize);
                }
            };

            animateResize(); // Start the animation
        }

        // Remove old markers from the scene once resizing begins
        scene.remove(markers);
        genericMarkers[region] = markers; // Update the genericMarkers object with resized markers
    } else {
        console.warn(`No markers found for the region: ${region}`);
    }
});
});
// Updated function name to avoid conflict
function convertLonLatToXYZ(radius, lon, lat) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);

  const x = -(radius * Math.sin(phi) * Math.cos(theta));
  const z = radius * Math.sin(phi) * Math.sin(theta);
  const y = radius * Math.cos(phi);

  return { x, y, z };
}
function createWaveMesh(options) {
  const geometry = new THREE.PlaneBufferGeometry(0.5, 0.5); // Default plane geometry in XOY plane
  const texture = textures.aperture;

  const material = new THREE.MeshBasicMaterial({
    color: 0x46dff0,
    map: texture,
    transparent: true, // Use transparent PNG textures
    opacity: 1.0,
    depthWrite: false // Disable depth write for transparency layering
  });

  const mesh = new THREE.Mesh(geometry, material);
// Helper function to convert longitude and latitude to XYZ coordinates
function lon2xyz(radius, lon, lat) {
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lon + 180) * (Math.PI / 180);

  return {
    x: -(radius * Math.sin(phi) * Math.cos(theta)),
    z: radius * Math.sin(phi) * Math.sin(theta),
    y: radius * Math.cos(phi)
  };
}
  // Convert longitude and latitude to spherical coordinates
  const coord = lon2xyz(options.radius * 1.001, options.lon, options.lat);
  const size = options.radius * 0.12; // Size of the rectangular plane mesh
  mesh.scale.set(size, size, size); // Set mesh size
  mesh.userData['size'] = size; // Custom property: static size
  mesh.userData['scale'] = Math.random() * 1.0; // Custom property: dynamic scaling factor

  // Set mesh position
  mesh.position.set(coord.x, coord.y, coord.z);

  // Align mesh normal to the globe surface
  const coordVec3 = new THREE.Vector3(coord.x, coord.y, coord.z).normalize();
  const meshNormal = new THREE.Vector3(0, 0, 1); // Default mesh normal is along Z-axis
  mesh.quaternion.setFromUnitVectors(meshNormal, coordVec3);

  return mesh;
}

  // Globe radius and texture
  const radius = 5.1; // Earth radius
    const textures = {
      aperture: new THREE.TextureLoader().load('js/aperture.png')
    };

  function createLightPillar(options) {
    const height = options.radius * 0.3;
    const geometry = new THREE.PlaneBufferGeometry(options.radius * 0.05, height);
    geometry.rotateX(Math.PI / 2);
    geometry.translate(0, 0, height / 2);
// Check light column texture
console.log('Light column texture:', textures.light_column);
    const material = new THREE.MeshBasicMaterial({
      map: options.textures.light_column || new THREE.Texture(),
      color:
        options.index === 0
          ? options.punctuation.lightColumn.startColor
          : options.punctuation.lightColumn.endColor,
      transparent: true,
      side: THREE.DoubleSide,
      depthWrite: false, //是否对深度缓冲区有任何的影响
    });

    const mesh = new THREE.Mesh(geometry, material);
    const group = new THREE.Group();

    // 两个光柱交叉叠加
    group.add(mesh, mesh.clone().rotateZ(Math.PI / 2)); //几何体绕x轴旋转了，所以mesh旋转轴变为z

    // 经纬度转球面坐标
    //const SphereCoord = convertLonLatToXYZ(options.radius, options.lon, options.lat); //SphereCoord球面坐标
    //const SphereCoord = convertLonLatToXYZ(options.radius * 1.01, options.lon, options.lat); // Offset radius slightly
    const SphereCoord = convertLonLatToXYZ(options.radius * 1.01, options.lon, options.lat); // Slight offset
group.position.set(SphereCoord.x, SphereCoord.y, SphereCoord.z);
    const coordVec3 = new THREE.Vector3(SphereCoord.x, SphereCoord.y, SphereCoord.z).normalize();
    const meshNormal = new THREE.Vector3(0, 0, 1);
    group.quaternion.setFromUnitVectors(meshNormal, coordVec3);
    //const axesHelper = new THREE.AxesHelper(5.1 * 0.2);
//group.add(axesHelper);

    return group;
  }

  function createPointMesh(options) {
    const geometry = new THREE.PlaneBufferGeometry(1, 1); //默认在XOY平面上
    const mesh = new THREE.Mesh(geometry, options.material);

    // 经纬度转球面坐标
    const coord = convertLonLatToXYZ(options.radius * 1.001, options.lon, options.lat);
    const size = options.radius * 0.05; // 矩形平面Mesh的尺寸
    mesh.scale.set(size, size, size); // 设置mesh大小

    // 设置mesh位置
    mesh.position.set(coord.x, coord.y, coord.z);
    const coordVec3 = new THREE.Vector3(coord.x, coord.y, coord.z).normalize();
    const meshNormal = new THREE.Vector3(0, 0, 1);
    mesh.quaternion.setFromUnitVectors(meshNormal, coordVec3);

    return mesh;
  }

  // Helper function to convert longitude and latitude to sphere coordinates
// Function to create light pillars and wave effects
async function addMarkupPoints(fromLatLng, toLatLng) {
   
  const pointsData = [
        { startArray: fromLatLng, endArray: [] },
        { startArray: toLatLng, endArray: [] }
    ];
    console.log('Points Data:', pointsData);

    const options = {
  data: pointsData,
  earth: { radius: earthRadius }, // Replace with your globe radius
  textures: {
    label: textureLoader.load('js/label.png'),
    wave: textureLoader.load('js/aperture.png'),
    light_column: textureLoader.load(
        'js/light_column.png',
        () => {
            console.log('Light column texture loaded');
        },
        undefined, // No onProgress callback
        (err) => {
            console.error('Error loading light column texture:', err);
        }
    )
  },
  punctuation: { circleColor: 0xe99f68, // A vibrant blue for circles
  lightColumn: {
    startColor:  0xffffff, // Yellow
    endColor: 0xffffff,   // Orange
  }, }, // Example color
  //data: pointsData
};
const { data, textures, punctuation } = options; // Destructure options for readability

  const markupPointGroup = new THREE.Group(); // Group to hold all markup points
  const waveMeshArr = []; // Array to keep track of wave meshes

  // Helper function to convert lat/lon to 3D Vector
  function latLngToVector3(lat, lon, radius) {
    const phi = (90 - lat) * (Math.PI / 180); // Latitude to radians
    const theta = (lon + 180) * (Math.PI / 180); // Longitude to radians

    const x = -(radius * Math.sin(phi) * Math.cos(theta));
    const z = (radius * Math.sin(phi) * Math.sin(theta));
    const y = radius * Math.cos(phi);

    return new THREE.Vector3(x, y, z);
  }

  // Helper function to create a point mesh
  function createPointMesh({ radius, lon, lat, material }) {
    const geometry = new THREE.PlaneGeometry(5, 5); // Adjust size as needed
    const mesh = new THREE.Mesh(geometry, material);

    const position = latLngToVector3(lat, lon, radius);
    mesh.position.copy(position);
    mesh.lookAt(new THREE.Vector3(0, 0, 0)); // Ensure it faces outward from the globe
    return mesh;
  }

  await Promise.all(data.map(async (item) => {
    const { lat, lng } = item.startArray || {};
    if (!lng || !lat) {
        console.error('Longitude or Latitude missing:', item.startArray);
        return; // Skip if coordinates are missing
    }

    console.log('Start Array:', item.startArray);
    console.log('Longitude:', lng, 'Latitude:', lat);
// Define material for punctuation
console.log('Label texture:', textures.label);
    // Define material for punctuation
    const punctuationMaterial = new THREE.MeshBasicMaterial({
        color: punctuation.circleColor,
        map: textures.label, // Load texture from options
        transparent: true,
        depthWrite: false,
        side: THREE.BackSide,
    });


    // Create base mesh for the start point
    const baseMesh = createPointMesh({ radius: 5.1, lon: lng, lat, material: punctuationMaterial });
    // Set the size by adjusting the scale
const size = 0.15; // Adjust this value for the desired size
baseMesh.scale.set(size, size, size);
    markupPointGroup.add(baseMesh);

    // Create light pillar for the start point
    const lightPillar = createLightPillar({
        radius: 5.1,
        lon: lng,
        lat,
        index: 0,
        textures,
        punctuation,
    });
    markupPointGroup.add(lightPillar);
    console.log('Creating light pillar with options:', { radius: 5.1, lon: lng, lat, index: 0, textures, punctuation });

    console.log('Light pillar created:', lightPillar);
    // Create wave mesh for the start point
    const waveMesh = createWaveMesh({ radius: 5.1, lon: lng, lat, textures });
    markupPointGroup.add(waveMesh);
    waveMeshArr.push(waveMesh);

    // Process all end points for the current start point
    await Promise.all(item.endArray.map((endObj) => {
        const endLon = endObj.lng; // Longitude
        const endLat = endObj.lat; // Latitude

        // Create base mesh for the end point
        const endMesh = createPointMesh({ radius: 5.1, lon: endLon, lat: endLat, material: punctuationMaterial });
        markupPointGroup.add(endMesh);

        // Create light pillar for the end point
        const endLightPillar = createLightPillar({
            radius: 5.1,
            lon: endLon,
            lat: endLat,
            index: 1,
            textures,
            punctuation,
        });
        markupPointGroup.add(endLightPillar);

        // Create wave mesh for the end point
        const endWaveMesh = createWaveMesh({ radius: 5.1, lon: endLon, lat: endLat, textures });
        markupPointGroup.add(endWaveMesh);
        waveMeshArr.push(endWaveMesh);
    }));
}));


  // Add all markup points to the main Earth group
  globe2.add(markupPointGroup);
}
  
    async function fetchMarkers(location, category) {
      try {
        const normalizedLocation = normalizeLocation(location); // Normalize input
    // Get today's date
    const today = new Date();
    const tomorrow = new Date();
    tomorrow.setDate(today.getDate() + 1);

    // Get the first day of the current month
    const monthlyStartDate = new Date(today.getFullYear(), today.getMonth(), 1);
    const monthlyEndDate = new Date(today.getFullYear(), today.getMonth() + 3, 0); // 3 months ahead

    // Format the dates to YYYY-MM-DD
    const monthlyStart = monthlyStartDate.toISOString().split('T')[0];
    const monthlyEnd = monthlyEndDate.toISOString().split('T')[0];

    const checkin = document.getElementById('checkin').value;
    const checkout = document.getElementById('checkout').value;
    const guests = document.getElementById('adults').value;

    // Now define the searchUrl properly
    let searchUrl = `https://www.airbnb.com/s/${location}/homes?tab_id=home_tab&refinement_paths%5B%5D=%2Fhomes&adults=2&flexible_trip_lengths%5B%5D=one_week&monthly_start_date=${monthlyStart}&monthly_length=3&monthly_end_date=${monthlyEnd}&price_filter_input_type=0&channel=EXPLORE&date_picker_type=calendar&checkin=${checkin}&checkout=${checkout}&adults=${guests}&source=structured_search_input_header&search_type=unknown&price_filter_num_nights=1&drawer_open=true`;

    // Fetch markers from your backend
    const response = await fetch(`http://localhost:3000/scrape-airbnb?searchUrl=${encodeURIComponent(searchUrl)}`);
    // Extract posts and markers from the response
    const { markers } = await response.json(); 
    console.log("Fetched markers:", markers);  // Log the response to check its format

    if (!Array.isArray(markers)) {
      throw new Error('Expected markers to be an array');
    }
    // Clear existing markers and add new ones
    clearExistingMarkers();
    addMarkersToGlobe(markers);  // Call the function to add markers
  } catch (error) {
    console.error("Failed to fetch markers:", error);
  }
}

// Function to add markers to the globe
function addMarkersToGlobe(markers) {
  markers.forEach(marker => {
    const { lat, lng } = marker;

    // Convert lat/lng to 3D vector just like the flight path
    const markerVector = latLngToVector3(lat, lng, earthRadius);

    // Create the marker mesh
    const markerMesh = createMarkerMesh();

    // Set the marker position based on the 3D vector
    markerMesh.position.set(markerVector.x, markerVector.y, markerVector.z);

    // Ensure the marker faces outward from the globe
    markerMesh.lookAt(new THREE.Vector3(0, 0, 0));

    // Add the marker to the scene
    scene.add(markerMesh);
  });
}
// Function to create marker mesh for the globe
function createMarkerMesh(lat, lng) {
  const markerGeometry = new THREE.PlaneGeometry(0.25, 0.25);
  const markerMaterial =  new THREE.MeshBasicMaterial({
    color: 0xff385c,
    side: THREE.DoubleSide,
    onBeforeCompile: (shader) => {
      shader.uniforms.time = globalUniforms.time;
      shader.vertexShader = `
      	attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
        	vPhase = phase; // de-synch of ripples
        `
      );
      shader.fragmentShader = `
      	uniform float time;
        varying float vPhase;
      	${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });
  markerMaterial.defines = { USE_UV: '' };

  const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);

  // Convert lat/lng to 3D coordinates on the globe
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lng + 180) * (Math.PI / 180);

  const x = -(earthRadius * Math.sin(phi) * Math.cos(theta));
  const y = earthRadius * Math.cos(phi);
  const z = earthRadius * Math.sin(phi) * Math.sin(theta);

  markerMesh.position.set(x, y, z);
  // Ensure the marker faces outward from the globe by making it look at the globe's center
  markerMesh.lookAt(new THREE.Vector3(0, 0, 0));

  return markerMesh;
}

	  // Clear the existing markers and add new ones based on the category
    clearExistingMarkers();
    markersData.forEach(markers => {
       scene.remove(markers);
    });


	  document.addEventListener("DOMContentLoaded", function() {

  // Add event listener to the submit button
  document.getElementById('submitRegion').addEventListener('click', function() {
    // Close the initial region popup
    document.getElementById('regionPopup').style.display = 'none';

    // Show the confirmation message
    //document.getElementById('confirmationMessage').style.display = 'block';

    // Hide the confirmation message after 10 seconds
    //setTimeout(function() {
      //document.getElementById('confirmationMessage').style.display = 'none';
    //}, 20000);

    // Capture the selected region from the dropdown
    const selectedRegion = document.getElementById('regionSelect').value;

    // Pan to the selected region
    panToRegion(selectedRegion);
    // Resize and update all markers with animation
Object.keys(genericMarkers).forEach(region => {
    const markers = genericMarkers[region];
    if (markers) {
        const originalMarkerSize = 1; // Assume original size was 0.5
        const targetMarkerSize = 0.25; // Target size (smaller)

        for (let i = 0; i < markers.count; i++) {
            const instanceMatrix = new THREE.Matrix4();
            markers.getMatrixAt(i, instanceMatrix);

            // Create marker mesh with initial size
            const markerMesh = new THREE.Mesh(new THREE.PlaneGeometry(originalMarkerSize, originalMarkerSize), markerMaterial);
            markerMesh.applyMatrix4(instanceMatrix);
            scene.add(markerMesh); // Add marker to scene

            // Animation variables
            let currentSize = originalMarkerSize;

            // Function to animate the resizing of markers
            const animateResize = () => {
                currentSize = THREE.MathUtils.lerp(currentSize, targetMarkerSize, 0.1); // Smoothly interpolate size
                markerMesh.geometry.dispose(); // Dispose of old geometry
                markerMesh.geometry = new THREE.PlaneGeometry(currentSize, currentSize); // Update geometry

                if (Math.abs(currentSize - targetMarkerSize) > 0.01) {
                    requestAnimationFrame(animateResize); // Continue animation until target size is reached
                } else {
                    // Ensure final size is set
                    markerMesh.geometry.dispose();
                    markerMesh.geometry = new THREE.PlaneGeometry(targetMarkerSize, targetMarkerSize);
                }
            };

            animateResize(); // Start the animation
        }

        // Remove old markers from the scene once resizing begins
        scene.remove(markers);
        genericMarkers[region] = markers; // Update the genericMarkers object with resized markers
    } else {
        console.warn(`No markers found for the region: ${region}`);
    }
});
  });
});
// Always visible region select button
document.getElementById('regionSelectBtn').style.display = 'block';
document.getElementById('regionSelectBtn').addEventListener('click', function () {
  if (!document.getElementById('regionSelectDropdown')) {
    let regionSelect = document.createElement('select');
    regionSelect.id = 'regionSelectDropdown';
    regionSelect.innerHTML = `
      <option value="africa">Africa</option>
      <option value="europe">Europe</option>
      <option value="america">America</option>
      <option value="south america">South America</option>
      <option value="carribbean">Carribbean</option>
      <option value="asia">Asia</option>
      <option value="world">World</option>
    `;
    this.insertAdjacentElement('afterend', regionSelect);
    regionSelect.style.display = 'block';
    regionSelect.addEventListener('change', function () {
      let selectedRegion = this.value;
      const selectedCategory = document.getElementById('priceCategorySelect').value;
	// Load appropriate markers for the selected region and category
    //loadMarkersForRegionAndCategory(selectedRegion, selectedCategory);
    fetchMarkers(selectedRegion, selectedCategory);
      panToRegion(selectedRegion);
      console.log("Region button clicked. Resizing all markers.");

  // Iterate through all regions in the genericMarkers object
Object.keys(genericMarkers).forEach(region => {
    const markers = genericMarkers[region];

    if (markers) {
        console.log(`Resizing markers for region: ${region}`);

        // Create smaller geometry (target size)
        const smallerMarkerSize = 0.25; // Target size
        const originalMarkerSize = 1; // Assuming original size was 0.5

        for (let i = 0; i < markers.count; i++) {
            const instanceMatrix = new THREE.Matrix4();
            markers.getMatrixAt(i, instanceMatrix);

            const markerMesh = new THREE.Mesh(new THREE.PlaneGeometry(originalMarkerSize, originalMarkerSize), markerMaterial);
            markerMesh.applyMatrix4(instanceMatrix);

            scene.add(markerMesh); // Add the marker to the scene

            // Animate the size reduction of the marker
            let currentSize = originalMarkerSize;
            const targetSize = smallerMarkerSize;

            const animateResize = () => {
                currentSize = THREE.MathUtils.lerp(currentSize, targetSize, 0.1); // Smooth transition
                markerMesh.geometry.dispose(); // Dispose of old geometry
                markerMesh.geometry = new THREE.PlaneGeometry(currentSize, currentSize); // Update geometry

                if (Math.abs(currentSize - targetSize) > 0.01) {
                    requestAnimationFrame(animateResize); // Continue animating until close to target size
                }
            };

            animateResize(); // Start the animation
        }

        // Remove old markers from the scene once resizing begins
        scene.remove(markers);
    } else {
        console.warn(`No markers found for the region: ${region}`);
    }
});
    });
	  // Load markers based on region and price category
// Load markers based on region and price category
async function loadMarkersForRegionAndCategory(region, category) {
    try {
        // Display loading spinner or status
        updateSpinnerText("Fetching listings for " + region + "...");

        // Fetch the listings data from your backend based on region and category
        const response = await fetch(`http://localhost:3000/get-markers?region=${region}&category=${category}`, {
  method: 'GET',
  credentials: 'include',  // If you need cookies or credentials
});
        const markersData = await response.json();  // Assuming the backend returns a JSON array of markers
        console.log(`Fetching markers from: ${url}`);
	    console.log(`Fetching markers from: http://localhost:3000/get-markers?region=${region}&category=${category}`);

        // Clear the existing markers before adding new ones
        clearExistingMarkers();
        
        // Add the new markers to the scene
        markersData.forEach(marker => {
            console.log('Creating marker:', marker);
	    let markerObject = createMarker(marker);
	    console.log('Marker Object:', markerObject);
	    scene.add(markerObject);

        });

        // Update spinner text once loading is complete
        updateSpinnerText("Listings loaded for " + region);
	    console.log(`Fetching markers from: http://localhost:3000/get-markers?region=${region}&category=${category}`);


    } catch (error) {
        console.error("Error fetching listings:", error);
        updateSpinnerText("Error loading listings for " + region);
    }
}
async function fetchMarkers(region, category) {
  try {
    const response = await fetch(`http://localhost:3000/get-markers?region=${region}&category=${category}`);
    const markers = await response.json();
     // Clear the existing markers before adding new ones
     clearExistingMarkers();
    addMarkersToGlobe(markers);  // Call the function to add markers
  } catch (error) {
    console.error("Failed to fetch markers:", error);
  }
}

// Function to add markers to the globe
function addMarkersToGlobe(markers) {
  markers.forEach(marker => {
    const { lat, lng } = marker;
    const markerMesh = createMarkerMesh(lat, lng);
    scene.add(markerMesh);
  });
}

// Function to create marker mesh for the globe
function createMarkerMesh(lat, lng) {
  const markerGeometry = new THREE.PlaneGeometry(0.25, 0.25);
  const markerMaterial =  new THREE.MeshBasicMaterial({
    color: 0xff385c,
    side: THREE.DoubleSide,
    onBeforeCompile: (shader) => {
      shader.uniforms.time = globalUniforms.time;
      shader.vertexShader = `
      	attribute float phase;
        varying float vPhase;
        ${shader.vertexShader}
      `.replace(
        `#include <begin_vertex>`,
        `#include <begin_vertex>
        	vPhase = phase; // de-synch of ripples
        `
      );
      shader.fragmentShader = `
      	uniform float time;
        varying float vPhase;
      	${shader.fragmentShader}
      `.replace(
        `vec4 diffuseColor = vec4( diffuse, opacity );`,
        `
        vec2 lUv = (vUv - 0.5) * 2.;
        float val = 0.;
        float lenUv = length(lUv);
        val = max(val, 1. - step(0.25, lenUv)); // central circle
        val = max(val, step(0.4, lenUv) - step(0.5, lenUv)); // outer circle

        float tShift = fract(time * 0.5 + vPhase);
        val = max(val, step(0.4 + (tShift * 0.6), lenUv) - step(0.5 + (tShift * 0.5), lenUv)); // ripple

        if (val < 0.5) discard;

        vec4 diffuseColor = vec4( diffuse, opacity );`
      );
    },
  });
  markerMaterial.defines = { USE_UV: '' };

  const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);

  // Convert lat/lng to 3D coordinates on the globe
  const phi = (90 - lat) * (Math.PI / 180);
  const theta = (lng + 180) * (Math.PI / 180);

  const x = -(earthRadius * Math.sin(phi) * Math.cos(theta));
  const y = earthRadius * Math.cos(phi);
  const z = earthRadius * Math.sin(phi) * Math.sin(theta);

  markerMesh.position.set(x, y, z);
  // Ensure the marker faces outward from the globe by making it look at the globe's center
  markerMesh.lookAt(new THREE.Vector3(0, 0, 0));

  return markerMesh;
}

	  // Clear the existing markers and add new ones based on the category
    clearExistingMarkers();
    markersData.forEach(markers => {
       scene.add(markers);
    });
};
});
function getMarkersDataForPopularListings(region) {
    // Example logic: Fetch the popular listings for the specified region
    return [
        { lat: 51.5074, lon: -0.1278, name: 'London Popular Listing', price: '£120/night' },
        // Add more markers...
    ];
}

function getMarkersDataForCheapestListings(region) {
    // Example logic: Fetch the cheapest listings for the specified region
    return [
        { lat: 48.8566, lon: 2.3522, name: 'Paris Cheapest Listing', price: '€50/night' },
        // Add more markers...
    ];
}
	  function getMarkersDataForMidPriceListings(region) {
    // Example logic: Fetch the cheapest listings for the specified region
    return [
        { lat: 48.8566, lon: 2.3522, name: 'Paris Cheapest Listing', price: '€50/night' },
        // Add more markers...
    ];
}
	  function getMarkersDataForExpensiveListings(region) {
    // Example logic: Fetch the cheapest listings for the specified region
    return [
        { lat: 48.8566, lon: 2.3522, name: 'Paris Cheapest Listing', price: '€50/night' },
        // Add more markers...
    ];
}
  
// Declare the position variable
let position;
let zoomLevel;
// Pan to region based on dropdown selection
// Pan to region based on dropdown selection
// Pan to region based on dropdown selection
function panToRegion(region) {
  console.log(`Selected region: ${region}`);  // Debug

  switch (region) {
    case 'africa':
      // Adjusted x value to pan the camera more to the right
      position = { x: 16.0, y: 0, z: 1.74 }; 
      zoomLevel = 1.5;
      //zoomLevel = 2.5987766446450165;
      break;
      
    case 'europe': 
      position = { x: 4.0, y: 2.91, z: 0.55 }; 
      zoomLevel = 2.0;
      //zoomLevel = 3.352075053253554;
      break;
      
    case 'america': 
      position = { x: 0, y: 2.55, z: 4.42 }; 
      //zoomLevel = 2.0;
      zoomLevel = 3.3270465054184264; 
      break;
      
    case 'south america': 
      position = { x: 1.5, y: -0.5, z: 4.3 }; 
      //zoomLevel = 1.7;
      zoomLevel = 3.26378534559376;
      break;
      
    case 'carribbean': 
      position = { x: 0.65, y: 2.0, z: 4.6 }; 
      //zoomLevel = 2.4;
      zoomLevel = 4.260619061597975; 
      break;
      
    case 'asia': 
      position = { x: -0.89, y: 3.28, z: -3.92 }; 
      //zoomLevel = 1.9;
      zoomLevel = 3.391380517604982;
      break;
      
    case 'world': 
      position = { x: 16.0, y: 0, z: 1.74 }; 
      zoomLevel = 1.4;
      //zoomLevel = 10.101116854411483;
      break;
    default: return;
  }
  // Ensure zoomLevel is properly set
  if (typeof zoomLevel === 'undefined') {
    console.error('Zoom level is undefined');
    return;
  }
  // Initial pan based on default zoom level
  executePan(position, zoomLevel);
}
// Function to handle the pan and zoom
function executePan(position, zoomLevel) {
  stopAllTweens(); // Stop any existing animations
  controls.autoRotate = true; // Stop auto-rotation
  console.log(`Panning to x:${position.x}, y:${position.y}, z:${position.z}, zoom:${zoomLevel}`);  // Debug

  // Call to animate camera pan with smoother transitions
  animateCameraPan(position.x, position.y, position.z, zoomLevel);
}


function animateCameraPan(x, y, z, zoomLevel) {
  const currentZoom = camera.zoom;
  const zoomDelta = zoomLevel - currentZoom;
  const targetPosition = { x, y, z };
  const currentPosition = { x: camera.position.x, y: camera.position.y, z: camera.position.z };

  // Smooth camera panning
  new TWEEN.Tween(currentPosition)
    .to(targetPosition, 3000)  // Smooth panning over 3 seconds
    .easing(TWEEN.Easing.Quadratic.InOut)
    .onUpdate(() => {
      camera.position.set(currentPosition.x, currentPosition.y, currentPosition.z);
      camera.lookAt(0, 0, 0);  // Keep the globe centered
    })
    .start();

  // Smooth camera zooming
  new TWEEN.Tween({ zoom: currentZoom })
    .to({ zoom: zoomLevel }, 3000)  // Smooth zoom over 3 seconds
    .easing(TWEEN.Easing.Quadratic.InOut)
    .onUpdate(function (tween) {
      camera.zoom = tween.zoom;
      camera.updateProjectionMatrix(); // Update the camera projection matrix
    })
    .onComplete(function () {
      // Restart slow auto-rotation after panning and zooming
      setTimeout(function () {
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.25; // Slow rotation speed
      }, 500);
    })
    .start();
}


console.log('Globe:', globe2);
console.log('Camera:', camera);

  // custom globe material
  const globeMaterial = globe.material;
  material.bumpScale = 10;
  new THREE.TextureLoader().load(
    "//unpkg.com/three-globe/example/img/earth-water.png",
    (texture) => {
      globeMaterial.specularMap = texture;
      globeMaterial.specular = new THREE.Color("grey");
      globeMaterial.shininess = 15;
    }
  );

  /*setTimeout(() => {
    // wait for scene to be populated (asynchronously)
    var dl = new THREE.DirectionalLight(0xffffff, 1);
    dl.position.set(1, 1, 1);
    //scene.add(dl); // change light position to see the specularMap's effect
  });
  // White directional light at half intensity shining from the top.
  const directionalLight = new THREE.DirectionalLight(0x909090, 1);
  directionalLight.position.set(-1, -1, -1);
  scene.add(directionalLight);
  var dl2 = new THREE.DirectionalLight(0xffffff, 1);
  dl2.position.set(0, 1, 1);
  //scene.add(dl2); // change light position to see the specularMap's effect
  var dl3 = new THREE.DirectionalLight(0xffffff, 1);
  dl3.position.set(3, 2, 1);
  //scene.add(dl3);
  const light2 = new THREE.AmbientLight(0x808080); // soft white light
  scene.add(light2);

  var light = new THREE.DirectionalLight(0xf0f0f0, 1);
  light.position.set(5, 3, 5);
  scene.add(light);*/
	  
// Create directional light and reduce its intensity
	  setTimeout(() => {
var dl = new THREE.DirectionalLight(0xffffff, 0.3); // Reduced intensity
dl.position.set(1, 1, 1);
//scene.add(dl); // Add the light to the scene
	  });
// White directional light at half intensity shining from the top, with reduced intensity
const directionalLight = new THREE.DirectionalLight(0x909090, 0.5); // Reduced intensity
directionalLight.position.set(-1, -1, -1);
scene.add(directionalLight);

var dl2 = new THREE.DirectionalLight(0xffffff, 0.5); // Reduced intensity
dl2.position.set(0, 1, 1);
//scene.add(dl2);

var dl3 = new THREE.DirectionalLight(0xffffff, 0.5); // Reduced intensity
dl3.position.set(3, 2, 1);
//scene.add(dl3);

// Ambient light for soft lighting, unchanged
const light2 = new THREE.AmbientLight(0x808080); // soft white light
scene.add(light2);

var light = new THREE.DirectionalLight(0xf0f0f0, 0.5); // Reduced intensity
light.position.set(5, 3, 5);
scene.add(light);

// Update intensity for directional lights dynamically if needed
directionalLight.intensity = 0.5;
dl2.intensity = 0.5;
dl3.intensity = 0.5;
    // Markers Data
  const markersData2 = [
    {
      //Africa
      id: 1,
      position: [5.1, 1.2, 1.5],
      iframeSrc: "https://rss.app/embed/v1/list/hKdSIKMe0o5AmG18",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"false"
    },
    // ... Add other markers here
    {
      //Europe
      id: 2,
      position: [5.1, 0.7, 1.8],
      iframeSrc: "https://rss.app/embed/v1/list/sum7m4TJWVJk8HMN",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //America
      id: 3,
      position: [5.1, 0.9, 0],
      iframeSrc: "https://rss.app/embed/v1/list/chAYVOo3llbQzNLo",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //South America
      id: 4,
      position: [5.1, 1.6, 0.4],
      iframeSrc: "https://rss.app/embed/v1/list/DP9kzxo2dohbbgST",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Middle East
      id: 5,
      position: [5.1, 1, 2.3],
      iframeSrc: "https://rss.app/embed/v1/list/JCYAnBzooyfhbDvO",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Asia
      id: 6,
      position: [5.1, 0.9, 3],
      iframeSrc: "https://rss.app/embed/v1/list/pUeauCbzsXuVe3eC",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Japan
      id: 7,
      position: [5.1, 0.9, 4],
      iframeSrc: "https://rss.app/embed/v1/list/d6hKxeycgIlya2NK",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      // Jamaica
      id: 8,
      position: [5.1, 1.2, 0.2],
      iframeSrc: "https://rss.app/embed/v1/list/qvlJz8EBa0yKiH2i",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //UK
      id: 9,
      position: [5.1, 0.6, 1.45],
      iframeSrc: "https://rss.app/embed/v1/list/VQIhB1FM0tC17q5Y",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
  ];
  const markersDataforCheapestAirbnbs = [
    {
      //Africa
      id: 1,
      position: [5.1, 1.2, 1.5],
      iframeSrc: "https://rss.app/embed/v1/list/hKdSIKMe0o5AmG18",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"false"
    },
    // ... Add other markers here
    {
      //Europe
      id: 2,
      position: [5.1, 0.7, 1.8],
      iframeSrc: "https://rss.app/embed/v1/list/sum7m4TJWVJk8HMN",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //America
      id: 3,
      position: [5.1, 0.9, 0],
      iframeSrc: "https://rss.app/embed/v1/list/chAYVOo3llbQzNLo",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //South America
      id: 4,
      position: [5.1, 1.6, 0.4],
      iframeSrc: "https://rss.app/embed/v1/list/DP9kzxo2dohbbgST",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Middle East
      id: 5,
      position: [5.1, 1, 2.3],
      iframeSrc: "https://rss.app/embed/v1/list/JCYAnBzooyfhbDvO",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Asia
      id: 6,
      position: [5.1, 0.9, 3],
      iframeSrc: "https://rss.app/embed/v1/list/pUeauCbzsXuVe3eC",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Japan
      id: 7,
      position: [5.1, 0.9, 4],
      iframeSrc: "https://rss.app/embed/v1/list/d6hKxeycgIlya2NK",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      // Jamaica
      id: 8,
      position: [5.1, 1.2, 0.2],
      iframeSrc: "https://rss.app/embed/v1/list/qvlJz8EBa0yKiH2i",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //UK
      id: 9,
      position: [5.1, 0.6, 1.45],
      iframeSrc: "https://rss.app/embed/v1/list/VQIhB1FM0tC17q5Y",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
  ];
	  const markersDataforMidPriceAirbnbs = [
    {
      //Africa
      id: 1,
      position: [5.1, 1.2, 1.5],
      iframeSrc: "https://rss.app/embed/v1/list/hKdSIKMe0o5AmG18",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"false"
    },
    // ... Add other markers here
    {
      //Europe
      id: 2,
      position: [5.1, 0.7, 1.8],
      iframeSrc: "https://rss.app/embed/v1/list/sum7m4TJWVJk8HMN",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //America
      id: 3,
      position: [5.1, 0.9, 0],
      iframeSrc: "https://rss.app/embed/v1/list/chAYVOo3llbQzNLo",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //South America
      id: 4,
      position: [5.1, 1.6, 0.4],
      iframeSrc: "https://rss.app/embed/v1/list/DP9kzxo2dohbbgST",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Middle East
      id: 5,
      position: [5.1, 1, 2.3],
      iframeSrc: "https://rss.app/embed/v1/list/JCYAnBzooyfhbDvO",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Asia
      id: 6,
      position: [5.1, 0.9, 3],
      iframeSrc: "https://rss.app/embed/v1/list/pUeauCbzsXuVe3eC",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Japan
      id: 7,
      position: [5.1, 0.9, 4],
      iframeSrc: "https://rss.app/embed/v1/list/d6hKxeycgIlya2NK",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      // Jamaica
      id: 8,
      position: [5.1, 1.2, 0.2],
      iframeSrc: "https://rss.app/embed/v1/list/qvlJz8EBa0yKiH2i",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //UK
      id: 9,
      position: [5.1, 0.6, 1.45],
      iframeSrc: "https://rss.app/embed/v1/list/VQIhB1FM0tC17q5Y",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
  ];
	  const markersDataforExpensiveAirbnbs = [
    {
      //Africa
      id: 1,
      position: [5.1, 1.2, 1.5],
      iframeSrc: "https://rss.app/embed/v1/list/hKdSIKMe0o5AmG18",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"false"
    },
    // ... Add other markers here
    {
      //Europe
      id: 2,
      position: [5.1, 0.7, 1.8],
      iframeSrc: "https://rss.app/embed/v1/list/sum7m4TJWVJk8HMN",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //America
      id: 3,
      position: [5.1, 0.9, 0],
      iframeSrc: "https://rss.app/embed/v1/list/chAYVOo3llbQzNLo",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //South America
      id: 4,
      position: [5.1, 1.6, 0.4],
      iframeSrc: "https://rss.app/embed/v1/list/DP9kzxo2dohbbgST",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Middle East
      id: 5,
      position: [5.1, 1, 2.3],
      iframeSrc: "https://rss.app/embed/v1/list/JCYAnBzooyfhbDvO",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Asia
      id: 6,
      position: [5.1, 0.9, 3],
      iframeSrc: "https://rss.app/embed/v1/list/pUeauCbzsXuVe3eC",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //Japan
      id: 7,
      position: [5.1, 0.9, 4],
      iframeSrc: "https://rss.app/embed/v1/list/d6hKxeycgIlya2NK",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      // Jamaica
      id: 8,
      position: [5.1, 1.2, 0.2],
      iframeSrc: "https://rss.app/embed/v1/list/qvlJz8EBa0yKiH2i",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
    {
      //UK
      id: 9,
      position: [5.1, 0.6, 1.45],
      iframeSrc: "https://rss.app/embed/v1/list/VQIhB1FM0tC17q5Y",
      sandbox:"allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox",
      frameborder:"0",
      loading:"eager",
      width:"275",
      height:"300",
      scrolling:"yes",
      allowfullscreen:"true"
    },
  ];
  // Marker Geometry and Material
  //const markerGeometry = new THREE.PlaneGeometry();
   /*const markerGeometry = new THREE.PlaneGeometry(5, 5); // Increase size for mobile
if (window.innerWidth <= 768) {
  markerGeometry.scale(1.25, 1.25, 1.25); // Scale markers for mobile
}*/


  
  // Creating Markers
  //const markerCount = markersData2.length;
  //const markers = new THREE.InstancedMesh(markerGeometry, markerMaterial2, markerCount);
  
  //const dummy = new THREE.Object3D();
  //const phaseArray = [];
  
  /*markersData2.forEach((data, index) => {
    //const [radius, phi, theta] = data.position;
    dummy.position.setFromSphericalCoords(radius, phi, theta);
    dummy.lookAt(dummy.position.clone().setLength(radius + 1));
    dummy.updateMatrix();
    markers.setMatrixAt(index, dummy.matrix);
    phaseArray.push(Math.random());
    data.worldPosition = dummy.position.clone();
  });
  
  markerGeometry.setAttribute('phase', new THREE.InstancedBufferAttribute(new Float32Array(phaseArray), 1));
  //scene.add(markers);*/
    // Labels Container
  const labelsContainer = document.getElementById('labels-container');
  let mouseActivityTimeout; // Timeout to resume autorotation after user interaction
  // Mouse Activity Event Listeners
function stopAutoRotateOnUserInteraction() {
    controls.autoRotate = false;

    // Clear any existing timeout
    clearTimeout(mouseActivityTimeout);

    // Resume autorotation after 5 seconds of inactivity (adjust as needed)
    mouseActivityTimeout = setTimeout(() => {
            controls.autoRotate = true;
    }, 2000); // 5 seconds of no mouse activity
}

// Stop autorotate on user interaction (mouse and touch)
//window.addEventListener('mousemove', stopAutoRotateOnUserInteraction);
window.addEventListener('mousedown', stopAutoRotateOnUserInteraction);
//window.addEventListener('mouseup', stopAutoRotateOnUserInteraction);
window.addEventListener('touchstart', stopAutoRotateOnUserInteraction);
window.addEventListener('touchend', stopAutoRotateOnUserInteraction);
  // Create Labels
markersData.forEach((data) => {
  // Create Label Div
  const labelDiv = document.createElement('div');
  labelDiv.className = 'marker-label';
  labelDiv.id = `label-${data.id}`;
// Set the z-index
labelDiv.style.zIndex = '22009'; // Adjust the value as needed
  // Close Button
  const closeButton = document.createElement('button');
  closeButton.className = 'close-button';
  closeButton.innerText = '×';
  labelDiv.appendChild(closeButton);
  
  // Close Button Event Listener
  closeButton.addEventListener('click', (event) => {
    console.log('Close button clicked'); // Check if this appears in the console
    event.stopPropagation(); // Stop the event from propagating up the DOM
    labelDiv.classList.remove('active');
    
    // Resume globe autorotation when the label is closed
    controls.autoRotate = true;
    
    // Re-enable the OrbitControls
    controls.enabled = true;
  });

  // Content Div
  const contentDiv = document.createElement('div');
  contentDiv.className = 'content';
  labelDiv.appendChild(contentDiv);
// Set the z-index
contentDiv.style.zIndex = '22009'; // Adjust the value as needed
  // Append to Labels Container
  labelsContainer.appendChild(labelDiv);

  // CSS2DObject
  const labelObject = new CSS2DObject(labelDiv);
  labelObject.position.copy(data.worldPosition);
  scene.add(labelObject);

  // Store label object for interaction
  data.labelObject = labelObject;
  labelDiv.addEventListener('mousedown', (event) => {
    event.stopPropagation();
  });
  labelDiv.addEventListener('touchstart', (event) => {
    event.stopPropagation();
  });
});

// Raycaster for Interaction
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();
	  
/*let activeLabel = null; // Keep track of the currently open iframe
	  
window.addEventListener('pointerdown', (event) => {
  pointer.x = (event.clientX / innerWidth) * 2 - 1;
  pointer.y = -(event.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(pointer, camera);

  const intersects = raycaster.intersectObject(markers).filter((m) => {
    return m.uv.subScalar(0.5).length() * 2 < 0.25;
  });

  if (intersects.length > 0) {
    const instanceId = intersects[0].instanceId;
    const data = markersData[instanceId];
	  
	  // Update Label Content
    const labelDiv = document.getElementById(`label-${data.id}`);
    const contentDiv = labelDiv.querySelector('.content');
	  
	  // Check if the iframe is related to the marker (specific iframe)
    if (!contentDiv.querySelector('iframe')) {
	  // Add loading spinner inside the content div
    contentDiv.innerHTML = `
    <div class="loading-spinner" style="pointer-events:none;"></div>
    <iframe src="${data.iframeSrc}" frameborder="0" width="275" height="249" scrolling="no" allowfullscreen="true" sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox" loading="eager"></iframe>
    `;

    const iframe = labelDiv.querySelector('iframe');
    const spinner = contentDiv.querySelector('.loading-spinner');
	   
	    // Show Label
    labelDiv.classList.add('active');
	    
	    iframe.addEventListener('load', () => {
	console.log('Iframe loaded');
	    
	// Hide loading spinner when iframe finishes loading
      spinner.style.display = 'none';
      iframe.style.pointerEvents = 'all'; // Enable iframe interaction after loading
       iframe.contentWindow.addEventListener('blur', () => {
	console.log('Iframe lost focus');
        controls.enabled = true; // Re-enable the controls when iframe loses focus
      });
		    // Close any previously active label
      if (activeLabel && activeLabel !== labelDiv) {
        activeLabel.classList.remove('active');
      }
		    // Set the new active label
      activeLabel = labelDiv;
	    
    });
	  // Show loading spinner
    //const loadingIcon = document.getElementById('loadingIcon');
    //loadingIcon.style.display = 'block';
	  
    // Add a listener to detect when the iframe loses focus and re-enable the controls
    console.log(iframe); // Check if the iframe element is being correctly selected
    }
  } */
// Close iframe when clicking outside of it
	  
    // Close iframe when clicking outside of it
   /* document.addEventListener('click', function(event) {
  if (!labelDiv.contains(event.target)) {
    // Check if the label is already active, toggle it off
    if (labelDiv.classList.contains('active')) {
      labelDiv.classList.remove('active');
      controls.autoRotate = true;
      controls.enabled = true;
    } else {
      // Re-enable the iframe on click
      labelDiv.classList.add('active');
      controls.autoRotate = false;
      controls.enabled = false;
    }
  }
});
/*        document.addEventListener('pointerdown', function(event) {
          if (!labelDiv.contains(event.target)) {
          labelDiv.classList.remove('active');
          controls.autoRotate = true;
          controls.enabled = true;
          activeLabel = null; // No active label after close
        }
      });

	    // Stop the globe's autorotation and disable OrbitControls
    controls.autoRotate = false;
    controls.enabled = false; // Disable the controls while interacting with the iframe

  }
}
});*/
	  // Define different markers data sets
const markersDataSets = {
    general: markersData,
  cheapest: markersDataforCheapestAirbnbs,
  midPrice: markersDataforMidPriceAirbnbs,
  expensive: markersDataforExpensiveAirbnbs,
};

let activeMarkersData = markersData; // Default to markersData
let activeLabel = null; // Keep track of open iframe
//let markers; // Declare it outside, so it is accessible globally.

function loadMarkers(selectedCategory) {
  // Remove existing markers from the scene
  //scene.remove(markers);
	
// Set active markers data
  activeMarkersData = markersDataSets[selectedCategory];

  // Create new markers for the selected category
  //const markerCount = activeMarkersData.length;
  //const markers = new THREE.InstancedMesh(markerGeometry, markerMaterial, markerCount);
  //const dummy = new THREE.Object3D();
//const dummy = new THREE.Object3D();
  activeMarkersData.forEach((data, index) => {
    const [radius, phi, theta] = data.position;
    dummy.position.setFromSphericalCoords(radius, phi, theta);
    dummy.lookAt(dummy.position.clone().setLength(radius + 1));
    dummy.updateMatrix();
    markers.setMatrixAt(index, dummy.matrix);
    data.worldPosition = dummy.position.clone();
  });

  //scene.add(markers);

  // Add interactivity to the new markers
  setupMarkerInteraction();
}
	  
// Set up marker click event
function setupMarkerInteraction() {
  window.addEventListener('pointerdown', (event) => {
    pointer.x = (event.clientX / innerWidth) * 2 - 1;
    pointer.y = -(event.clientY / innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);

    const intersects = raycaster.intersectObject(markers).filter((m) => {
      return m.uv.subScalar(0.5).length() * 2 < 0.25;
    });

    if (intersects.length > 0) {
      const instanceId = intersects[0].instanceId;
      const data = activeMarkersData[instanceId];

      // Check if this label is already active and close it
      if (activeLabel && activeLabel === document.getElementById(`label-${data.id}`)) {
        closeIframe(event); // Close if clicking on the same active label
        return;
      }

      // Otherwise, proceed to open the clicked marker
      openMarkerLabel(data);
    }
  });
}

function openMarkerLabel(data) {
  const labelDiv = document.getElementById(`label-${data.id}`);
  const contentDiv = labelDiv.querySelector('.content');

  if (!contentDiv.querySelector('iframe')) {
    contentDiv.innerHTML = `
      <div class="loading-spinner" style="pointer-events:none;"></div>
      <iframe src="${data.iframeSrc}" frameborder="0" width="275" height="249" scrolling="yes" allowfullscreen="true" sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox" loading="eager"></iframe>
    `;

    const iframe = labelDiv.querySelector('iframe');
    const spinner = contentDiv.querySelector('.loading-spinner');

    iframe.addEventListener('load', () => {
      spinner.style.display = 'none';
      iframe.style.pointerEvents = 'all';
    });
  }

  labelDiv.classList.add('active');
  controls.autoRotate = false;
  controls.enabled = false;
  renderer.domElement.style.pointerEvents = 'none';

  // Close any previously active label
  if (activeLabel && activeLabel !== labelDiv) {
    activeLabel.classList.remove('active');
  }

  activeLabel = labelDiv;

  // Add global listener for closing
  document.addEventListener('pointerdown', closeIframe);
}

	// Function to close the active iframe if clicked outside
  function closeIframe(event) {
  if (activeLabel && !activeLabel.contains(event.target)) {
    activeLabel.classList.remove('active');
    controls.autoRotate = true;
    controls.enabled = true;
    renderer.domElement.style.pointerEvents = 'all'; // Re-enable interaction with the globe

    // Reset the active label, but keep it available for re-clicking
    activeLabel = null;
  }
}
	  // Add event listener for dropdown selection
document.getElementById('airbnbSelector').addEventListener('change', function() {
  const selectedCategory = this.value;
  loadMarkers(selectedCategory);
});

// Load markers for default category on page load
loadMarkers('general');
		    
	 /* let activeLabel = null; // Keep track of the currently open iframe

window.addEventListener('pointerdown', (event) => {
  pointer.x = (event.clientX / innerWidth) * 2 - 1;
  pointer.y = -(event.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(pointer, camera);

  const intersects = raycaster.intersectObject(markers).filter((m) => {
    return m.uv.subScalar(0.5).length() * 2 < 0.25;
  });

  if (intersects.length > 0) {
    const instanceId = intersects[0].instanceId;
    const data = markersData[instanceId];

    // Update Label Content
    const labelDiv = document.getElementById(`label-${data.id}`);
    const contentDiv = labelDiv.querySelector('.content');

    // Always update the content and attach the iframe, even if previously clicked
    contentDiv.innerHTML = `
      <div class="loading-spinner" style="pointer-events:none;"></div>
      <iframe src="${data.iframeSrc}" frameborder="0" width="275" height="249" scrolling="yes" allowfullscreen="true" sandbox="allow-same-origin allow-scripts allow-popups allow-forms allow-modals allow-popups-to-escape-sandbox" loading="eager"></iframe>
    `;

    const iframe = labelDiv.querySelector('iframe');
    const spinner = contentDiv.querySelector('.loading-spinner');

    labelDiv.classList.add('active');
    controls.autoRotate = false;
    controls.enabled = false;

    // Disable pointer events on the globe while interacting with the iframe
    renderer.domElement.style.pointerEvents = 'none';

    iframe.addEventListener('load', () => {
      spinner.style.display = 'none';
      iframe.style.pointerEvents = 'all'; // Enable iframe interaction after loading

      // Close any previously active label
      if (activeLabel && activeLabel !== labelDiv) {
        activeLabel.classList.remove('active');
      }

      // Set the new active label
      activeLabel = labelDiv;
    });

    // Remove previous `pointerdown` listeners if any
    document.removeEventListener('pointerdown', closeIframe);

    // Add event listener to close iframe when clicking outside
    document.addEventListener('pointerdown', closeIframe);
  }
});

// Function to close the active iframe if clicked outside
function closeIframe(event) {
  if (activeLabel && !activeLabel.contains(event.target)) {
    activeLabel.classList.remove('active');
    controls.autoRotate = true;
    controls.enabled = true;
    renderer.domElement.style.pointerEvents = 'all'; // Re-enable interaction with the globe
    activeLabel = null; // Clear the active label
  }
}
}*/




	  // Loading spinner functionality
/*document.getElementById('labels-container').addEventListener('click', function() {
  const loadingIcon = document.getElementById('loadingIcon');
  
  // Show loading icon when iframe is clicked
  loadingIcon.style.display = 'block';
  
  // Hide the loading icon after a set timeout (3 seconds in this case)
  setTimeout(() => {
    loadingIcon.style.display = 'none';
  }, 3000); // Adjust time as needed
});*/



// Animation Loop
//const clock = new THREE.Clock();
// Animation loop that ensures the TWEEN library is updated
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);
    
    // Update tween animations
    TWEEN.update(); 
	
    // Update time uniform for any shaders if needed
    globalUniforms.time.value = clock.getElapsedTime();

    // Update controls
    if (controls.enabled) {
        controls.update();
    }

    // Render the scene
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera); // If you're using labelRenderer
}
	  renderer.setSize(window.innerWidth, window.innerHeight);
window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
});


animate(); // Start the animation loop
/*function animate() {
  requestAnimationFrame(animate);
  TWEEN.update(); // Required to make the transition work
  // Update time uniform
  globalUniforms.time.value = clock.getElapsedTime();
	
  // Update controls
  if (controls.enabled) {
    controls.update();
  }

  // Render
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}

animate();*/

  </script>
</body>
</html>
